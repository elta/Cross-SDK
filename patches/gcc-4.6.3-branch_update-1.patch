Submitted By: Jim Gifford (jim at cross-lfs dot org)
Date: 08-25-2012
Initial Package Version: 4.6.3
Origin: Upstream
Upstream Status: Applied
Description: This is a branch update for gcc-4.6.3, and should be
             rechecked periodically.

This patch was made from Revision # 190659.

diff -Naur gcc-4.6.3.orig/boehm-gc/configure gcc-4.6.3/boehm-gc/configure
--- gcc-4.6.3.orig/boehm-gc/configure	2012-03-01 12:03:46.000000000 +0000
+++ gcc-4.6.3/boehm-gc/configure	2012-03-02 18:21:41.598223000 +0000
@@ -15246,6 +15246,17 @@
 fi
 done
 
+for ac_func in pthread_get_stackaddr_np
+do :
+  ac_fn_c_check_func "$LINENO" "pthread_get_stackaddr_np" "ac_cv_func_pthread_get_stackaddr_np"
+if test "x$ac_cv_func_pthread_get_stackaddr_np" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PTHREAD_GET_STACKADDR_NP 1
+_ACEOF
+
+fi
+done
+
 LIBS="$oldLIBS"
 
 # Configuration of machine-dependent code
diff -Naur gcc-4.6.3.orig/boehm-gc/configure.ac gcc-4.6.3/boehm-gc/configure.ac
--- gcc-4.6.3.orig/boehm-gc/configure.ac	2011-02-02 13:53:56.000000000 +0000
+++ gcc-4.6.3/boehm-gc/configure.ac	2012-03-02 18:21:41.598223000 +0000
@@ -392,6 +392,7 @@
 oldLIBS="$LIBS"
 LIBS="$LIBS $THREADLIBS"
 AC_CHECK_FUNCS([pthread_getattr_np])
+AC_CHECK_FUNCS([pthread_get_stackaddr_np])
 LIBS="$oldLIBS"
 
 # Configuration of machine-dependent code
diff -Naur gcc-4.6.3.orig/boehm-gc/include/gc_config.h.in gcc-4.6.3/boehm-gc/include/gc_config.h.in
--- gcc-4.6.3.orig/boehm-gc/include/gc_config.h.in	2009-08-22 13:22:20.000000000 +0000
+++ gcc-4.6.3/boehm-gc/include/gc_config.h.in	2012-03-02 18:21:41.598223000 +0000
@@ -87,6 +87,9 @@
 /* Define to 1 if you have the `pthread_getattr_np' function. */
 #undef HAVE_PTHREAD_GETATTR_NP
 
+/* Define to 1 if you have the `pthread_get_stackaddr_np_np' function. */
+#undef HAVE_PTHREAD_GET_STACKADDR_NP
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
diff -Naur gcc-4.6.3.orig/boehm-gc/include/private/gcconfig.h gcc-4.6.3/boehm-gc/include/private/gcconfig.h
--- gcc-4.6.3.orig/boehm-gc/include/private/gcconfig.h	2010-03-21 19:34:19.000000000 +0000
+++ gcc-4.6.3/boehm-gc/include/private/gcconfig.h	2012-03-02 18:21:41.598223000 +0000
@@ -1331,7 +1331,11 @@
 	 These aren't used when dyld support is enabled (it is by default) */
 #     define DATASTART ((ptr_t) get_etext())
 #     define DATAEND	((ptr_t) get_end())
-#     define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     ifdef HAVE_PTHREAD_GET_STACKADDR_NP
+#       define STACKBOTTOM (ptr_t)pthread_get_stackaddr_np(pthread_self())
+#     else
+#       define STACKBOTTOM ((ptr_t) 0xc0000000)
+#     endif
 #     define USE_MMAP
 #     define USE_MMAP_ANON
 #     define USE_ASM_PUSH_REGS
@@ -2011,7 +2015,11 @@
 	 These aren't used when dyld support is enabled (it is by default) */
 #     define DATASTART ((ptr_t) get_etext())
 #     define DATAEND	((ptr_t) get_end())
-#     define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#     ifdef HAVE_PTHREAD_GET_STACKADDR_NP
+#       define STACKBOTTOM (ptr_t)pthread_get_stackaddr_np(pthread_self())
+#     else
+#       define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#     endif
 #     define USE_MMAP
 #     define USE_MMAP_ANON
 #     ifdef GC_DARWIN_THREADS
diff -Naur gcc-4.6.3.orig/gcc/DATESTAMP gcc-4.6.3/gcc/DATESTAMP
--- gcc-4.6.3.orig/gcc/DATESTAMP	2012-03-01 00:17:53.000000000 +0000
+++ gcc-4.6.3/gcc/DATESTAMP	2012-08-25 00:16:37.466340000 +0000
@@ -1 +1 @@
-20120301
+20120825
diff -Naur gcc-4.6.3.orig/gcc/ada/gcc-interface/decl.c gcc-4.6.3/gcc/ada/gcc-interface/decl.c
--- gcc-4.6.3.orig/gcc/ada/gcc-interface/decl.c	2012-01-21 15:01:48.000000000 +0000
+++ gcc-4.6.3/gcc/ada/gcc-interface/decl.c	2012-05-26 10:44:06.390872000 +0000
@@ -120,8 +120,8 @@
   /* The value of the qualifier.  */
   tree qual;
 
-  /* The record associated with this variant.  */
-  tree record;
+  /* The type of the variant after transformation.  */
+  tree new_type;
 } variant_desc;
 
 DEF_VEC_O(variant_desc);
@@ -3157,11 +3157,16 @@
 		      {
 			tree old_variant = v->type;
 			tree new_variant = make_node (RECORD_TYPE);
+			tree suffix
+			  = concat_name (DECL_NAME (gnu_variant_part),
+					 IDENTIFIER_POINTER
+					 (DECL_NAME (v->field)));
 			TYPE_NAME (new_variant)
-			  = DECL_NAME (TYPE_NAME (old_variant));
+			  = concat_name (TYPE_NAME (gnu_type),
+					 IDENTIFIER_POINTER (suffix));
 			copy_and_substitute_in_size (new_variant, old_variant,
 						     gnu_subst_list);
-			v->record = new_variant;
+			v->new_type = new_variant;
 		      }
 		}
 	      else
@@ -3265,7 +3270,7 @@
 			    if (selected_variant)
 			      gnu_cont_type = gnu_type;
 			    else
-			      gnu_cont_type = v->record;
+			      gnu_cont_type = v->new_type;
 			  }
 			else
 			  /* The front-end may pass us "ghost" components if
@@ -7704,7 +7709,7 @@
 	  v->type = variant_type;
 	  v->field = gnu_field;
 	  v->qual = qual;
-	  v->record = NULL_TREE;
+	  v->new_type = NULL_TREE;
 
 	  /* Recurse on the variant subpart of the variant, if any.  */
 	  variant_subpart = get_variant_part (variant_type);
@@ -8457,7 +8462,9 @@
 
   /* First create the type of the variant part from that of the old one.  */
   new_union_type = make_node (QUAL_UNION_TYPE);
-  TYPE_NAME (new_union_type) = DECL_NAME (TYPE_NAME (old_union_type));
+  TYPE_NAME (new_union_type)
+    = concat_name (TYPE_NAME (record_type),
+		   IDENTIFIER_POINTER (DECL_NAME (old_variant_part)));
 
   /* If the position of the variant part is constant, subtract it from the
      size of the type of the parent to get the new size.  This manual CSE
@@ -8491,7 +8498,7 @@
 	continue;
 
       /* Retrieve the list of fields already added to the new variant.  */
-      new_variant = v->record;
+      new_variant = v->new_type;
       field_list = TYPE_FIELDS (new_variant);
 
       /* If the old variant had a variant subpart, we need to create a new
diff -Naur gcc-4.6.3.orig/gcc/c-typeck.c gcc-4.6.3/gcc/c-typeck.c
--- gcc-4.6.3.orig/gcc/c-typeck.c	2011-11-04 21:49:49.000000000 +0000
+++ gcc-4.6.3/gcc/c-typeck.c	2012-05-21 20:12:05.729358000 +0000
@@ -4315,6 +4315,11 @@
     ret = fold_build3_loc (colon_loc, COND_EXPR, result_type, ifexp, op1, op2);
   else
     {
+      if (int_operands)
+	{
+	  op1 = remove_c_maybe_const_expr (op1);
+	  op2 = remove_c_maybe_const_expr (op2);
+	}
       ret = build3 (COND_EXPR, result_type, ifexp, op1, op2);
       if (int_operands)
 	ret = note_integer_operands (ret);
diff -Naur gcc-4.6.3.orig/gcc/cgraph.c gcc-4.6.3/gcc/cgraph.c
--- gcc-4.6.3.orig/gcc/cgraph.c	2011-06-06 17:16:35.000000000 +0000
+++ gcc-4.6.3/gcc/cgraph.c	2012-03-25 09:39:32.217767000 +0000
@@ -1700,19 +1700,27 @@
   free_nodes = node;
 }
 
-/* Remove the node from cgraph.  */
+/* Remove the node from cgraph and all inline clones inlined into it.
+   Skip however removal of FORBIDDEN_NODE and return true if it needs to be
+   removed.  This allows to call the function from outer loop walking clone
+   tree.  */
 
-void
-cgraph_remove_node_and_inline_clones (struct cgraph_node *node)
+bool
+cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_node *forbidden_node)
 {
   struct cgraph_edge *e, *next;
+  bool found = false;
+
+  if (node == forbidden_node)
+    return true;
   for (e = node->callees; e; e = next)
     {
       next = e->next_callee;
       if (!e->inline_failed)
-        cgraph_remove_node_and_inline_clones (e->callee);
+        found |= cgraph_remove_node_and_inline_clones (e->callee, forbidden_node);
     }
   cgraph_remove_node (node);
+  return found;
 }
 
 /* Notify finalize_compilation_unit that given node is reachable.  */
diff -Naur gcc-4.6.3.orig/gcc/cgraph.h gcc-4.6.3/gcc/cgraph.h
--- gcc-4.6.3.orig/gcc/cgraph.h	2011-03-04 18:49:23.000000000 +0000
+++ gcc-4.6.3/gcc/cgraph.h	2012-03-25 09:39:32.217767000 +0000
@@ -547,7 +547,7 @@
 void cgraph_insert_node_to_hashtable (struct cgraph_node *node);
 void cgraph_remove_edge (struct cgraph_edge *);
 void cgraph_remove_node (struct cgraph_node *);
-void cgraph_remove_node_and_inline_clones (struct cgraph_node *);
+bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);
 void cgraph_release_function_body (struct cgraph_node *);
 void cgraph_node_remove_callees (struct cgraph_node *node);
 struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,
diff -Naur gcc-4.6.3.orig/gcc/cgraphunit.c gcc-4.6.3/gcc/cgraphunit.c
--- gcc-4.6.3.orig/gcc/cgraphunit.c	2011-03-11 13:27:26.000000000 +0000
+++ gcc-4.6.3/gcc/cgraphunit.c	2012-03-25 09:39:32.217767000 +0000
@@ -2157,8 +2157,19 @@
             first_clone->ipa_transforms_to_apply);
   first_clone->ipa_transforms_to_apply = NULL;
 
+  /* When doing recursive inlining, the clone may become unnecessary.
+     This is possible i.e. in the case when the recursive function is proved to be
+     non-throwing and the recursion happens only in the EH landing pad.
+     We can not remove the clone until we are done with saving the body.
+     Remove it now.  */
+  if (!first_clone->callers)
+    {
+      cgraph_remove_node_and_inline_clones (first_clone, NULL);
+      first_clone = NULL;
+    }
 #ifdef ENABLE_CHECKING
-  verify_cgraph_node (first_clone);
+  else
+    verify_cgraph_node (first_clone);
 #endif
   return first_clone;
 }
diff -Naur gcc-4.6.3.orig/gcc/combine.c gcc-4.6.3/gcc/combine.c
--- gcc-4.6.3.orig/gcc/combine.c	2012-02-09 17:29:38.000000000 +0000
+++ gcc-4.6.3/gcc/combine.c	2012-03-15 10:04:12.913641000 +0000
@@ -1788,6 +1788,10 @@
   if (set == 0)
     return 0;
 
+  /* The simplification in expand_field_assignment may call back to
+     get_last_value, so set safe guard here.  */
+  subst_low_luid = DF_INSN_LUID (insn);
+
   set = expand_field_assignment (set);
   src = SET_SRC (set), dest = SET_DEST (set);
 
diff -Naur gcc-4.6.3.orig/gcc/config/alpha/alpha.c gcc-4.6.3/gcc/config/alpha/alpha.c
--- gcc-4.6.3.orig/gcc/config/alpha/alpha.c	2011-08-06 18:41:14.000000000 +0000
+++ gcc-4.6.3/gcc/config/alpha/alpha.c	2012-08-09 21:49:40.880473000 +0000
@@ -2469,7 +2469,7 @@
     {
     case EQ:  case LE:  case LT:  case LEU:  case LTU:
     case UNORDERED:
-      /* We have these compares: */
+      /* We have these compares.  */
       cmp_code = code, branch_code = NE;
       break;
 
@@ -2706,13 +2706,15 @@
       switch (code)
 	{
 	case EQ: case LE: case LT: case LEU: case LTU:
+	case UNORDERED:
 	  /* We have these compares.  */
 	  cmp_code = code, code = NE;
 	  break;
 
 	case NE:
-	  /* This must be reversed.  */
-	  cmp_code = EQ, code = EQ;
+	case ORDERED:
+	  /* These must be reversed.  */
+	  cmp_code = reverse_condition (code), code = EQ;
 	  break;
 
 	case GE: case GT: case GEU: case GTU:
@@ -2732,6 +2734,14 @@
 	  gcc_unreachable ();
 	}
 
+      if (cmp_mode == DImode)
+	{
+	  if (!reg_or_0_operand (op0, DImode))
+	    op0 = force_reg (DImode, op0);
+	  if (!reg_or_8bit_operand (op1, DImode))
+	    op1 = force_reg (DImode, op1);
+	}
+
       tem = gen_reg_rtx (cmp_mode);
       emit_insn (gen_rtx_SET (VOIDmode, tem,
 			      gen_rtx_fmt_ee (cmp_code, cmp_mode,
@@ -2743,6 +2753,14 @@
       local_fast_math = 1;
     }
 
+  if (cmp_mode == DImode)
+    {
+      if (!reg_or_0_operand (op0, DImode))
+	op0 = force_reg (DImode, op0);
+      if (!reg_or_8bit_operand (op1, DImode))
+	op1 = force_reg (DImode, op1);
+    }
+
   /* We may be able to use a conditional move directly.
      This avoids emitting spurious compares.  */
   if (signed_comparison_operator (cmp, VOIDmode)
@@ -2761,11 +2779,13 @@
   switch (code)
     {
     case EQ:  case LE:  case LT:  case LEU:  case LTU:
+    case UNORDERED:
       /* We have these compares: */
       break;
 
     case NE:
-      /* This must be reversed.  */
+    case ORDERED:
+      /* These must be reversed.  */
       code = reverse_condition (code);
       cmov_code = EQ;
       break;
@@ -9628,18 +9648,19 @@
     }
 }
 
-/* Insert an unop between a noreturn function call and GP load.  */
+/* Insert an unop between sibcall or noreturn function call and GP load.  */
 
 static void
-alpha_pad_noreturn (void)
+alpha_pad_function_end (void)
 {
   rtx insn, next;
 
   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
     {
-      if (!CALL_P (insn)
-	  || !find_reg_note (insn, REG_NORETURN, NULL_RTX))
-        continue;
+      if (! (CALL_P (insn)
+	     && (SIBLING_CALL_P (insn)
+		 || find_reg_note (insn, REG_NORETURN, NULL_RTX))))
+	continue;
 
       next = next_active_insn (insn);
 
@@ -9660,8 +9681,28 @@
 static void
 alpha_reorg (void)
 {
-  /* Workaround for a linker error that triggers when an
-     exception handler immediatelly follows a noreturn function.
+  /* Workaround for a linker error that triggers when an exception
+     handler immediatelly follows a sibcall or a noreturn function.
+
+In the sibcall case:
+
+     The instruction stream from an object file:
+
+ 1d8:   00 00 fb 6b     jmp     (t12)
+ 1dc:   00 00 ba 27     ldah    gp,0(ra)
+ 1e0:   00 00 bd 23     lda     gp,0(gp)
+ 1e4:   00 00 7d a7     ldq     t12,0(gp)
+ 1e8:   00 40 5b 6b     jsr     ra,(t12),1ec <__funcZ+0x1ec>
+
+     was converted in the final link pass to:
+
+   12003aa88:   67 fa ff c3     br      120039428 <...>
+   12003aa8c:   00 00 fe 2f     unop
+   12003aa90:   00 00 fe 2f     unop
+   12003aa94:   48 83 7d a7     ldq     t12,-31928(gp)
+   12003aa98:   00 40 5b 6b     jsr     ra,(t12),12003aa9c <__func+0x1ec>
+
+And in the noreturn case:
 
      The instruction stream from an object file:
 
@@ -9681,11 +9722,11 @@
 
      GP load instructions were wrongly cleared by the linker relaxation
      pass.  This workaround prevents removal of GP loads by inserting
-     an unop instruction between a noreturn function call and
+     an unop instruction between a sibcall or noreturn function call and
      exception handler prologue.  */
 
   if (current_function_has_exception_handlers ())
-    alpha_pad_noreturn ();
+    alpha_pad_function_end ();
 
   if (alpha_tp != ALPHA_TP_PROG || flag_exceptions)
     alpha_handle_trap_shadows ();
diff -Naur gcc-4.6.3.orig/gcc/config/alpha/linux-unwind.h gcc-4.6.3/gcc/config/alpha/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/alpha/linux-unwind.h	2011-12-21 12:22:48.000000000 +0000
+++ gcc-4.6.3/gcc/config/alpha/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Alpha Linux.
-   Copyright (C) 2004, 2005, 2009, 2011 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2011, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -49,7 +49,7 @@
   else if (pc[1] == 0x201f015f)		/* lda $0,NR_rt_sigreturn */
     {
       struct rt_sigframe {
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
diff -Naur gcc-4.6.3.orig/gcc/config/arm/arm.c gcc-4.6.3/gcc/config/arm/arm.c
--- gcc-4.6.3.orig/gcc/config/arm/arm.c	2012-02-14 06:57:17.000000000 +0000
+++ gcc-4.6.3/gcc/config/arm/arm.c	2012-08-10 13:26:44.694722000 +0000
@@ -243,6 +243,7 @@
 static bool fa726te_sched_adjust_cost (rtx, rtx, rtx, int *);
 static enum machine_mode arm_preferred_simd_mode (enum machine_mode);
 static bool arm_class_likely_spilled_p (reg_class_t);
+static HOST_WIDE_INT arm_vector_alignment (const_tree type);
 static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);
 static bool arm_builtin_support_vector_misalignment (enum machine_mode mode,
 						     const_tree type,
@@ -579,6 +580,9 @@
 #undef TARGET_CLASS_LIKELY_SPILLED_P
 #define TARGET_CLASS_LIKELY_SPILLED_P arm_class_likely_spilled_p
 
+#undef TARGET_VECTOR_ALIGNMENT
+#define TARGET_VECTOR_ALIGNMENT arm_vector_alignment
+
 #undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE
 #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE \
   arm_vector_alignment_reachable
@@ -2005,7 +2009,8 @@
 			   global_options_set.x_param_values);
 
   /* ARM EABI defaults to strict volatile bitfields.  */
-  if (TARGET_AAPCS_BASED && flag_strict_volatile_bitfields < 0)
+  if (TARGET_AAPCS_BASED && flag_strict_volatile_bitfields < 0
+      && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   /* Enable sw prefetching at -O3 for CPUS that have prefetch, and we have deemed
@@ -4692,6 +4697,18 @@
   return gen_rtx_REG (mode, pcum->nregs);
 }
 
+/* The AAPCS sets the maximum alignment of a vector to 64 bits.  */
+static HOST_WIDE_INT
+arm_vector_alignment (const_tree type)
+{
+  HOST_WIDE_INT align = tree_low_cst (TYPE_SIZE (type), 0);
+
+  if (TARGET_AAPCS_BASED)
+    align = MIN (align, 64);
+
+  return align;
+}
+
 static unsigned int
 arm_function_arg_boundary (enum machine_mode mode, const_tree type)
 {
@@ -23422,8 +23439,11 @@
 	}
     }
 
-  arm_process_output_memory_barrier (emit, NULL);
+  /* Note: label is before barrier so that in cmp failure case we still get
+     a barrier to stop subsequent loads floating upwards past the ldrex
+     PR target/48126.  */
   arm_output_asm_insn (emit, 1, operands, "%sLSYB%%=:", LOCAL_LABEL_PREFIX);
+  arm_process_output_memory_barrier (emit, NULL);
 }
 
 static rtx
diff -Naur gcc-4.6.3.orig/gcc/config/arm/arm.h gcc-4.6.3/gcc/config/arm/arm.h
--- gcc-4.6.3.orig/gcc/config/arm/arm.h	2011-07-14 21:26:01.000000000 +0000
+++ gcc-4.6.3/gcc/config/arm/arm.h	2012-06-19 12:30:17.615240000 +0000
@@ -294,7 +294,8 @@
 #define TARGET_HAVE_DMB		(arm_arch7)
 
 /* Nonzero if this chip implements a memory barrier via CP15.  */
-#define TARGET_HAVE_DMB_MCR	(arm_arch6k && ! TARGET_HAVE_DMB)
+#define TARGET_HAVE_DMB_MCR	(arm_arch6 && ! TARGET_HAVE_DMB \
+				 && ! TARGET_THUMB1)
 
 /* Nonzero if this chip implements a memory barrier instruction.  */
 #define TARGET_HAVE_MEMORY_BARRIER (TARGET_HAVE_DMB || TARGET_HAVE_DMB_MCR)
diff -Naur gcc-4.6.3.orig/gcc/config/avr/avr-stdint.h gcc-4.6.3/gcc/config/avr/avr-stdint.h
--- gcc-4.6.3.orig/gcc/config/avr/avr-stdint.h	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/config/avr/avr-stdint.h	2012-06-04 09:53:04.873173000 +0000
@@ -0,0 +1,66 @@
+/* Definitions for <stdint.h> types on systems using newlib.
+   Copyright (C) 2012 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/*
+   The intention of this file is to supply definitions that work with
+   avr-gcc's -mint8 that sets int to an 8-bit type.
+
+   This file is intended to yield the same results as newlib-stdint.h,
+   but there are some differences to newlib-stdint.h:
+
+   - AVR is an 8-bit architecture that cannot access 16-bit values
+     atomically, this SIG_ATOMIC_TYPE is "char".
+
+   - For the same reason, [u]int_fast8_t is defined as 8-bit type.
+
+*/
+   
+#define SIG_ATOMIC_TYPE "char"
+
+#define INT8_TYPE "signed char"
+#define INT16_TYPE (INT_TYPE_SIZE == 16 ? "short int" : "long int")
+#define INT32_TYPE (INT_TYPE_SIZE == 16 ? "long int" : "long long int")
+#define INT64_TYPE (INT_TYPE_SIZE == 16 ? "long long int" : 0)
+#define UINT8_TYPE "unsigned char"
+#define UINT16_TYPE (INT_TYPE_SIZE == 16 ? "short unsigned int" : "long unsigned int")
+#define UINT32_TYPE (INT_TYPE_SIZE == 16 ? "long unsigned int" : "long long unsigned int")
+#define UINT64_TYPE (INT_TYPE_SIZE == 16 ? "long long unsigned int" : 0)
+
+#define INT_LEAST8_TYPE INT8_TYPE
+#define INT_LEAST16_TYPE INT16_TYPE
+#define INT_LEAST32_TYPE INT32_TYPE
+#define INT_LEAST64_TYPE INT64_TYPE
+#define UINT_LEAST8_TYPE UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE INT8_TYPE
+#define INT_FAST16_TYPE (INT_TYPE_SIZE == 16 ? "int" : INT16_TYPE)
+#define INT_FAST32_TYPE INT32_TYPE
+#define INT_FAST64_TYPE INT64_TYPE
+#define UINT_FAST8_TYPE UINT8_TYPE
+#define UINT_FAST16_TYPE (INT_TYPE_SIZE == 16 ? "unsigned int" : UINT16_TYPE)
+#define UINT_FAST32_TYPE UINT32_TYPE
+#define UINT_FAST64_TYPE UINT64_TYPE
+
+#define INTPTR_TYPE PTRDIFF_TYPE
+#ifndef UINTPTR_TYPE
+#define UINTPTR_TYPE SIZE_TYPE
+#endif
diff -Naur gcc-4.6.3.orig/gcc/config/avr/avr.c gcc-4.6.3/gcc/config/avr/avr.c
--- gcc-4.6.3.orig/gcc/config/avr/avr.c	2012-01-12 17:23:32.000000000 +0000
+++ gcc-4.6.3/gcc/config/avr/avr.c	2012-03-28 10:06:51.859458000 +0000
@@ -1879,12 +1879,9 @@
 	    }
 	  else if (test_hard_reg_class (STACK_REG, src))
 	    {
-              *l = 2;
-              return AVR_HAVE_8BIT_SP
-                ? (AS2 (in,%A0,__SP_L__) CR_TAB
-                   AS1 (clr,%B0))
-                : (AS2 (in,%A0,__SP_L__) CR_TAB
-                   AS2 (in,%B0,__SP_H__));
+	      *l = 2;	
+	      return (AS2 (in,%A0,__SP_L__) CR_TAB
+		      AS2 (in,%B0,__SP_H__));
 	    }
 
 	  if (AVR_HAVE_MOVW)
@@ -5177,10 +5174,9 @@
 
   default_file_start ();
 
-  fputs ("__SREG__ = 0x3f\n", asm_out_file);
-  if (!AVR_HAVE_8BIT_SP)
-    fputs ("__SP_H__ = 0x3e\n", asm_out_file);
-  fputs ("__SP_L__ = 0x3d\n", asm_out_file);
+  fputs ("__SREG__ = 0x3f\n"
+	 "__SP_H__ = 0x3e\n"
+	 "__SP_L__ = 0x3d\n", asm_out_file);
   
   fputs ("__tmp_reg__ = 0\n" 
          "__zero_reg__ = 1\n", asm_out_file);
diff -Naur gcc-4.6.3.orig/gcc/config/avr/avr.md gcc-4.6.3/gcc/config/avr/avr.md
--- gcc-4.6.3.orig/gcc/config/avr/avr.md	2011-12-02 19:14:15.000000000 +0000
+++ gcc-4.6.3/gcc/config/avr/avr.md	2012-03-28 10:06:51.859458000 +0000
@@ -299,7 +299,7 @@
   [(set (match_operand:HI 0 "stack_register_operand" "=q")
         (unspec_volatile:HI [(match_operand:HI 1 "register_operand"  "r")] 
 			    UNSPECV_WRITE_SP_IRQ_OFF))]
-  "!AVR_HAVE_8BIT_SP"
+  ""
   "out __SP_H__, %B1
 	out __SP_L__, %A1"
   [(set_attr "length" "2")
@@ -309,7 +309,7 @@
   [(set (match_operand:HI 0 "stack_register_operand" "=q")
         (unspec_volatile:HI [(match_operand:HI 1 "register_operand"  "r")] 
 			    UNSPECV_WRITE_SP_IRQ_ON))]
-  "!AVR_HAVE_8BIT_SP"
+  ""
   "cli
         out __SP_H__, %B1
 	sei
diff -Naur gcc-4.6.3.orig/gcc/config/avr/libgcc.S gcc-4.6.3/gcc/config/avr/libgcc.S
--- gcc-4.6.3.orig/gcc/config/avr/libgcc.S	2011-12-02 19:14:15.000000000 +0000
+++ gcc-4.6.3/gcc/config/avr/libgcc.S	2012-03-28 10:06:51.859458000 +0000
@@ -582,15 +582,6 @@
 	push r17
 	push r28
 	push r29
-#if defined (__AVR_HAVE_8BIT_SP__)
-;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level
-;;        so this lines are dead code.  To make it work, devices without
-;;        SP_H must get their own multilib(s), see PR51345.
-	in	r28,__SP_L__
-	sub	r28,r26
-	clr	r29
-	out	__SP_L__,r28
-#else
 	in	r28,__SP_L__
 	in	r29,__SP_H__
 	sub	r28,r26
@@ -600,7 +591,6 @@
 	out	__SP_H__,r29
 	out	__SREG__,__tmp_reg__
 	out	__SP_L__,r28
-#endif
 #if defined (__AVR_HAVE_EIJMP_EICALL__)
 	eijmp
 #else
@@ -635,15 +625,6 @@
 	ldd	r16,Y+4
 	ldd	r17,Y+3
 	ldd	r26,Y+2
-#if defined (__AVR_HAVE_8BIT_SP__)
-;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level
-;;        so this lines are dead code.  To make it work, devices without
-;;        SP_H must get their own multilib(s).
-	ldd	r29,Y+1
-	add	r28,r30
-	out	__SP_L__,r28
-	mov	r28, r26
-#else
 	ldd	r27,Y+1
 	add	r28,r30
 	adc	r29,__zero_reg__
@@ -654,7 +635,6 @@
 	out	__SP_L__,r28
 	mov_l	r28, r26
 	mov_h	r29, r27
-#endif
 	ret
 .endfunc
 #endif /* defined (L_epilogue) */
diff -Naur gcc-4.6.3.orig/gcc/config/bfin/linux-unwind.h gcc-4.6.3/gcc/config/bfin/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/bfin/linux-unwind.h	2009-04-09 15:00:19.000000000 +0000
+++ gcc-4.6.3/gcc/config/bfin/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Blackfin.
-   Copyright (C) 2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2007, 2009, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -48,10 +48,10 @@
     {
       struct rt_sigframe {
 	int sig;
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
 	char retcode[8];
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
 
diff -Naur gcc-4.6.3.orig/gcc/config/h8300/h8300.c gcc-4.6.3/gcc/config/h8300/h8300.c
--- gcc-4.6.3.orig/gcc/config/h8300/h8300.c	2010-12-01 13:46:36.000000000 +0000
+++ gcc-4.6.3/gcc/config/h8300/h8300.c	2012-03-29 02:15:29.973365000 +0000
@@ -416,7 +416,7 @@
     }
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 }
 
diff -Naur gcc-4.6.3.orig/gcc/config/host-linux.c gcc-4.6.3/gcc/config/host-linux.c
--- gcc-4.6.3.orig/gcc/config/host-linux.c	2010-11-29 14:09:41.000000000 +0000
+++ gcc-4.6.3/gcc/config/host-linux.c	2012-03-23 02:19:46.206744000 +0000
@@ -84,6 +84,8 @@
 # define TRY_EMPTY_VM_SPACE	0x60000000
 #elif defined(__mc68000__)
 # define TRY_EMPTY_VM_SPACE	0x40000000
+#elif defined(__ARM_EABI__)
+# define TRY_EMPTY_VM_SPACE     0x60000000
 #else
 # define TRY_EMPTY_VM_SPACE	0
 #endif
diff -Naur gcc-4.6.3.orig/gcc/config/i386/driver-i386.c gcc-4.6.3/gcc/config/i386/driver-i386.c
--- gcc-4.6.3.orig/gcc/config/i386/driver-i386.c	2012-01-19 20:15:29.000000000 +0000
+++ gcc-4.6.3/gcc/config/i386/driver-i386.c	2012-05-20 23:19:40.928753000 +0000
@@ -397,6 +397,7 @@
   unsigned int has_pclmul = 0, has_abm = 0, has_lwp = 0;
   unsigned int has_fma = 0, has_fma4 = 0, has_xop = 0;
   unsigned int has_bmi = 0, has_tbm = 0;
+  unsigned int has_rdrnd = 0, has_f16c = 0, has_fsgsbase = 0;
 
   bool arch;
 
@@ -444,6 +445,8 @@
   has_aes = ecx & bit_AES;
   has_pclmul = ecx & bit_PCLMUL;
   has_fma = ecx & bit_FMA;
+  has_f16c = ecx & bit_F16C;
+  has_rdrnd = ecx & bit_RDRND;
 
   has_cmpxchg8b = edx & bit_CMPXCHG8B;
   has_cmov = edx & bit_CMOV;
@@ -451,6 +454,13 @@
   has_sse = edx & bit_SSE;
   has_sse2 = edx & bit_SSE2;
 
+  if (max_level >= 7)
+    {
+      __cpuid_count (7, 0, eax, ebx, ecx, edx);
+
+      has_fsgsbase = ebx & bit_FSGSBASE;
+    }
+
   /* Check cpuid level of extended features.  */
   __cpuid (0x80000000, ext_level, ebx, ecx, edx);
 
@@ -711,10 +721,13 @@
       const char *avx = has_avx ? " -mavx" : " -mno-avx";
       const char *sse4_2 = has_sse4_2 ? " -msse4.2" : " -mno-sse4.2";
       const char *sse4_1 = has_sse4_1 ? " -msse4.1" : " -mno-sse4.1";
+      const char *rdrnd = has_rdrnd ? " -mrdrnd" : " -mno-rdrnd";
+      const char *f16c = has_f16c ? " -mf16c" : " -mno-f16c";
+      const char *fsgsbase = has_fsgsbase ? " -mfsgsbase" : " -mno-fsgsbase";
 
       options = concat (options, cx16, sahf, movbe, ase, pclmul,
 			popcnt, abm, lwp, fma, fma4, xop, bmi, tbm,
-			avx, sse4_2, sse4_1, NULL);
+			avx, sse4_2, sse4_1, rdrnd, f16c, fsgsbase, NULL);
     }
 
 done:
diff -Naur gcc-4.6.3.orig/gcc/config/i386/i386-protos.h gcc-4.6.3/gcc/config/i386/i386-protos.h
--- gcc-4.6.3.orig/gcc/config/i386/i386-protos.h	2011-01-13 20:01:57.000000000 +0000
+++ gcc-4.6.3/gcc/config/i386/i386-protos.h	2012-03-29 19:19:26.420040000 +0000
@@ -59,7 +59,8 @@
 extern bool constant_address_p (rtx);
 extern bool legitimate_pic_operand_p (rtx);
 extern bool legitimate_pic_address_disp_p (rtx);
-
+extern bool ix86_legitimize_reload_address (rtx, enum machine_mode,
+					    int, int, int);
 extern void print_reg (rtx, int, FILE*);
 extern void ix86_print_operand (FILE *, rtx, int);
 
diff -Naur gcc-4.6.3.orig/gcc/config/i386/i386.c gcc-4.6.3/gcc/config/i386/i386.c
--- gcc-4.6.3.orig/gcc/config/i386/i386.c	2012-02-22 19:17:42.000000000 +0000
+++ gcc-4.6.3/gcc/config/i386/i386.c	2012-05-22 09:20:15.992160000 +0000
@@ -46,6 +46,7 @@
 #include "target.h"
 #include "target-def.h"
 #include "langhooks.h"
+#include "reload.h"
 #include "cgraph.h"
 #include "gimple.h"
 #include "dwarf2.h"
@@ -2094,7 +2095,7 @@
 /* Feature tests against the various architecture variations, used to create
    ix86_arch_features based on the processor mask.  */
 static unsigned int initial_ix86_arch_features[X86_ARCH_LAST] = {
-  /* X86_ARCH_CMOVE: Conditional move was added for pentiumpro.  */
+  /* X86_ARCH_CMOV: Conditional move was added for pentiumpro.  */
   ~(m_386 | m_486 | m_PENT | m_K6),
 
   /* X86_ARCH_CMPXCHG: Compare and exchange was added for 80486.  */
@@ -3811,7 +3812,7 @@
 	   -mtune (rather than -march) points us to a processor that has them.
 	   However, the VIA C3 gives a SIGILL, so we only do that for i686 and
 	   higher processors.  */
-	if (TARGET_CMOVE
+	if (TARGET_CMOV
 	    && (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE)))
 	  x86_prefetch_sse = true;
 	break;
@@ -4181,12 +4182,6 @@
       target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
     }
 
-  /* For sane SSE instruction set generation we need fcomi instruction.
-     It is safe to enable all CMOVE instructions.  Also, RDRAND intrinsic
-     expands to a sequence that includes conditional move. */
-  if (TARGET_SSE || TARGET_RDRND)
-    TARGET_CMOVE = 1;
-
   /* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */
   {
     char *p;
@@ -12168,6 +12163,64 @@
   return false;
 }
 
+/* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to
+   replace the input X, or the original X if no replacement is called for.
+   The output parameter *WIN is 1 if the calling macro should goto WIN,
+   0 if it should not.  */
+
+bool
+ix86_legitimize_reload_address (rtx x,
+				enum machine_mode mode ATTRIBUTE_UNUSED,
+				int opnum, int type,
+				int ind_levels ATTRIBUTE_UNUSED)
+{
+  /* Reload can generate:
+
+     (plus:DI (plus:DI (unspec:DI [(const_int 0 [0])] UNSPEC_TP)
+		       (reg:DI 97))
+	      (reg:DI 2 cx))
+
+     This RTX is rejected from ix86_legitimate_address_p due to
+     non-strictness of base register 97.  Following this rejection, 
+     reload pushes all three components into separate registers,
+     creating invalid memory address RTX.
+
+     Following code reloads only the invalid part of the
+     memory address RTX.  */
+
+  if (GET_CODE (x) == PLUS
+      && REG_P (XEXP (x, 1))
+      && GET_CODE (XEXP (x, 0)) == PLUS
+      && REG_P (XEXP (XEXP (x, 0), 1)))
+    {
+      rtx base, index;
+      bool something_reloaded = false;
+
+      base = XEXP (XEXP (x, 0), 1);      
+      if (!REG_OK_FOR_BASE_STRICT_P (base))
+	{
+	  push_reload (base, NULL_RTX, &XEXP (XEXP (x, 0), 1), NULL,
+		       BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,
+		       opnum, (enum reload_type)type);
+	  something_reloaded = true;
+	}
+
+      index = XEXP (x, 1);
+      if (!REG_OK_FOR_INDEX_STRICT_P (index))
+	{
+	  push_reload (index, NULL_RTX, &XEXP (x, 1), NULL,
+		       INDEX_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,
+		       opnum, (enum reload_type)type);
+	  something_reloaded = true;
+	}
+
+      gcc_assert (something_reloaded);
+      return true;
+    }
+
+  return false;
+}
+
 /* Recognizes RTL expressions that are valid memory addresses for an
    instruction.  The MODE argument is the machine mode for the MEM
    expression that wants to use this address.
@@ -27177,8 +27230,8 @@
       arg_adjust = 0;
       if (optimize
 	  || target == 0
-	  || GET_MODE (target) != tmode
-	  || !insn_p->operand[0].predicate (target, tmode))
+	  || !register_operand (target, tmode)
+	  || GET_MODE (target) != tmode)
 	target = gen_reg_rtx (tmode);
     }
 
@@ -31377,9 +31430,9 @@
 	  tmp = gen_reg_rtx (GET_MODE_INNER (mode));
 	  ix86_expand_vector_extract (true, tmp, target, 1 - elt);
 	  if (elt == 0)
-	    tmp = gen_rtx_VEC_CONCAT (mode, tmp, val);
-	  else
 	    tmp = gen_rtx_VEC_CONCAT (mode, val, tmp);
+	  else
+	    tmp = gen_rtx_VEC_CONCAT (mode, tmp, val);
 	  emit_insn (gen_rtx_SET (VOIDmode, target, tmp));
 	  return;
 	}
@@ -31393,9 +31446,9 @@
       tmp = gen_reg_rtx (GET_MODE_INNER (mode));
       ix86_expand_vector_extract (false, tmp, target, 1 - elt);
       if (elt == 0)
-	tmp = gen_rtx_VEC_CONCAT (mode, tmp, val);
-      else
 	tmp = gen_rtx_VEC_CONCAT (mode, val, tmp);
+      else
+	tmp = gen_rtx_VEC_CONCAT (mode, tmp, val);
       emit_insn (gen_rtx_SET (VOIDmode, target, tmp));
       return;
 
@@ -32823,7 +32876,8 @@
         return ix86_cost->cond_not_taken_branch_cost;
 
       case vec_perm:
-        return 1;
+      case vec_promote_demote:
+        return ix86_cost->vec_stmt_cost;
 
       default:
         gcc_unreachable ();
diff -Naur gcc-4.6.3.orig/gcc/config/i386/i386.h gcc-4.6.3/gcc/config/i386/i386.h
--- gcc-4.6.3.orig/gcc/config/i386/i386.h	2011-06-29 20:15:32.000000000 +0000
+++ gcc-4.6.3/gcc/config/i386/i386.h	2012-05-04 17:48:56.810029000 +0000
@@ -424,7 +424,7 @@
 
 /* Feature tests against the various architecture variations.  */
 enum ix86_arch_indices {
-  X86_ARCH_CMOVE,		/* || TARGET_SSE */
+  X86_ARCH_CMOV,
   X86_ARCH_CMPXCHG,
   X86_ARCH_CMPXCHG8B,
   X86_ARCH_XADD,
@@ -435,12 +435,17 @@
 
 extern unsigned char ix86_arch_features[X86_ARCH_LAST];
 
-#define TARGET_CMOVE		ix86_arch_features[X86_ARCH_CMOVE]
+#define TARGET_CMOV		ix86_arch_features[X86_ARCH_CMOV]
 #define TARGET_CMPXCHG		ix86_arch_features[X86_ARCH_CMPXCHG]
 #define TARGET_CMPXCHG8B	ix86_arch_features[X86_ARCH_CMPXCHG8B]
 #define TARGET_XADD		ix86_arch_features[X86_ARCH_XADD]
 #define TARGET_BSWAP		ix86_arch_features[X86_ARCH_BSWAP]
 
+/* For sane SSE instruction set generation we need fcomi instruction.
+   It is safe to enable all CMOVE instructions.  Also, RDRAND intrinsic
+   expands to a sequence that includes conditional move. */
+#define TARGET_CMOVE		(TARGET_CMOV || TARGET_SSE || TARGET_RDRND)
+
 #define TARGET_FISTTP		(TARGET_SSE3 && TARGET_80387)
 
 extern int x86_prefetch_sse;
@@ -1668,6 +1673,17 @@
 
 #define LEGITIMATE_CONSTANT_P(X)  legitimate_constant_p (X)
 
+/* Try a machine-dependent way of reloading an illegitimate address
+   operand.  If we find one, push the reload and jump to WIN.  This
+   macro is used in only one place: `find_reloads_address' in reload.c.  */
+
+#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, INDL, WIN)	\
+do {									\
+  if (ix86_legitimize_reload_address ((X), (MODE), (OPNUM),		\
+				      (int)(TYPE), (INDL)))		\
+    goto WIN;								\
+} while (0)
+
 /* If defined, a C expression to determine the base term of address X.
    This macro is used in only one place: `find_base_term' in alias.c.
 
diff -Naur gcc-4.6.3.orig/gcc/config/i386/i386.md gcc-4.6.3/gcc/config/i386/i386.md
--- gcc-4.6.3.orig/gcc/config/i386/i386.md	2012-01-12 10:33:42.000000000 +0000
+++ gcc-4.6.3/gcc/config/i386/i386.md	2012-05-21 12:59:53.696085000 +0000
@@ -233,9 +233,6 @@
 
   ;; For BMI support
   UNSPEC_BEXTR
-
-  ;; For RDRAND support
-  UNSPEC_RDRAND
 ])
 
 (define_c_enum "unspecv" [
@@ -270,6 +267,9 @@
   UNSPECV_WRFSBASE
   UNSPECV_WRGSBASE
   UNSPECV_SPLIT_STACK_RETURN
+
+  ;; For RDRAND support
+  UNSPECV_RDRAND
 ])
 
 ;; Constants to represent pcomtrue/pcomfalse variants
@@ -16349,7 +16349,8 @@
 (define_insn "*x86_mov<mode>cc_0_m1_neg"
   [(set (match_operand:SWI48 0 "register_operand" "=r")
 	(neg:SWI48 (match_operator 1 "ix86_carry_flag_operator"
-		    [(reg FLAGS_REG) (const_int 0)])))]
+		    [(reg FLAGS_REG) (const_int 0)])))
+   (clobber (reg:CC FLAGS_REG))]
   ""
   "sbb{<imodesuffix>}\t%0, %0"
   [(set_attr "type" "alu")
@@ -18357,9 +18358,9 @@
 
 (define_insn "rdrand<mode>_1"
   [(set (match_operand:SWI248 0 "register_operand" "=r")
-	(unspec:SWI248 [(const_int 0)] UNSPEC_RDRAND))
+	(unspec_volatile:SWI248 [(const_int 0)] UNSPECV_RDRAND))
    (set (reg:CCC FLAGS_REG)
-	(unspec:CCC [(const_int 0)] UNSPEC_RDRAND))]
+	(unspec_volatile:CCC [(const_int 0)] UNSPECV_RDRAND))]
   "TARGET_RDRND"
   "rdrand\t%0"
   [(set_attr "type" "other")
diff -Naur gcc-4.6.3.orig/gcc/config/i386/linux-unwind.h gcc-4.6.3/gcc/config/i386/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/i386/linux-unwind.h	2011-01-03 20:52:22.000000000 +0000
+++ gcc-4.6.3/gcc/config/i386/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,6 @@
 /* DWARF2 EH unwinding support for AMD x86-64 and x86.
-   Copyright (C) 2004, 2005, 2006, 2009, 2010 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2006, 2009, 2010, 2012 Free Software Foundation,
+   Inc.
 
 This file is part of GCC.
 
@@ -133,9 +134,9 @@
     {
       struct rt_sigframe {
 	int sig;
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
diff -Naur gcc-4.6.3.orig/gcc/config/i386/sse.md gcc-4.6.3/gcc/config/i386/sse.md
--- gcc-4.6.3.orig/gcc/config/i386/sse.md	2011-10-27 21:55:22.000000000 +0000
+++ gcc-4.6.3/gcc/config/i386/sse.md	2012-06-17 14:09:00.121097000 +0000
@@ -392,18 +392,7 @@
   DONE;
 })
 
-(define_expand "avx_movu<ssemodesuffix><avxmodesuffix>"
-  [(set (match_operand:AVXMODEF2P 0 "nonimmediate_operand" "")
-	(unspec:AVXMODEF2P
-	  [(match_operand:AVXMODEF2P 1 "nonimmediate_operand" "")]
-	  UNSPEC_MOVU))]
-  "AVX_VEC_FLOAT_MODE_P (<MODE>mode)"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (<MODE>mode, operands[1]);
-})
-
-(define_insn "*avx_movu<ssemodesuffix><avxmodesuffix>"
+(define_insn "avx_movu<ssemodesuffix><avxmodesuffix>"
   [(set (match_operand:AVXMODEF2P 0 "nonimmediate_operand" "=x,m")
 	(unspec:AVXMODEF2P
 	  [(match_operand:AVXMODEF2P 1 "nonimmediate_operand" "xm,x")]
@@ -429,18 +418,7 @@
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
 
-(define_expand "<sse>_movu<ssemodesuffix>"
-  [(set (match_operand:SSEMODEF2P 0 "nonimmediate_operand" "")
-	(unspec:SSEMODEF2P
-	  [(match_operand:SSEMODEF2P 1 "nonimmediate_operand" "")]
-	  UNSPEC_MOVU))]
-  "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (<MODE>mode, operands[1]);
-})
-
-(define_insn "*<sse>_movu<ssemodesuffix>"
+(define_insn "<sse>_movu<ssemodesuffix>"
   [(set (match_operand:SSEMODEF2P 0 "nonimmediate_operand" "=x,m")
 	(unspec:SSEMODEF2P
 	  [(match_operand:SSEMODEF2P 1 "nonimmediate_operand" "xm,x")]
@@ -452,18 +430,7 @@
    (set_attr "movu" "1")
    (set_attr "mode" "<MODE>")])
 
-(define_expand "avx_movdqu<avxmodesuffix>"
-  [(set (match_operand:AVXMODEQI 0 "nonimmediate_operand" "")
-	(unspec:AVXMODEQI
-	  [(match_operand:AVXMODEQI 1 "nonimmediate_operand" "")]
-	  UNSPEC_MOVU))]
-  "TARGET_AVX"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (<MODE>mode, operands[1]);
-})
-
-(define_insn "*avx_movdqu<avxmodesuffix>"
+(define_insn "avx_movdqu<avxmodesuffix>"
   [(set (match_operand:AVXMODEQI 0 "nonimmediate_operand" "=x,m")
 	(unspec:AVXMODEQI
 	  [(match_operand:AVXMODEQI 1 "nonimmediate_operand" "xm,x")]
@@ -475,17 +442,7 @@
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
-(define_expand "sse2_movdqu"
-  [(set (match_operand:V16QI 0 "nonimmediate_operand" "")
-	(unspec:V16QI [(match_operand:V16QI 1 "nonimmediate_operand" "")]
-		      UNSPEC_MOVU))]
-  "TARGET_SSE2"
-{
-  if (MEM_P (operands[0]) && MEM_P (operands[1]))
-    operands[1] = force_reg (V16QImode, operands[1]);
-})
-
-(define_insn "*sse2_movdqu"
+(define_insn "sse2_movdqu"
   [(set (match_operand:V16QI 0 "nonimmediate_operand" "=x,m")
 	(unspec:V16QI [(match_operand:V16QI 1 "nonimmediate_operand" "xm,x")]
 		      UNSPEC_MOVU))]
@@ -1324,14 +1281,14 @@
 		(parallel [(const_int 0)]))
 	      (vec_select:DF (match_dup 1) (parallel [(const_int 1)])))
 	    (plusminus:DF
-	      (vec_select:DF (match_dup 1) (parallel [(const_int 2)]))
-	      (vec_select:DF (match_dup 1) (parallel [(const_int 3)]))))
-	  (vec_concat:V2DF
-	    (plusminus:DF
 	      (vec_select:DF
 		(match_operand:V4DF 2 "nonimmediate_operand" "xm")
 		(parallel [(const_int 0)]))
-	      (vec_select:DF (match_dup 2) (parallel [(const_int 1)])))
+	      (vec_select:DF (match_dup 2) (parallel [(const_int 1)]))))
+	  (vec_concat:V2DF
+	    (plusminus:DF
+	      (vec_select:DF (match_dup 1) (parallel [(const_int 2)]))
+	      (vec_select:DF (match_dup 1) (parallel [(const_int 3)])))
 	    (plusminus:DF
 	      (vec_select:DF (match_dup 2) (parallel [(const_int 2)]))
 	      (vec_select:DF (match_dup 2) (parallel [(const_int 3)]))))))]
@@ -5058,7 +5015,7 @@
 	  (vec_select:DF (match_dup 0) (parallel [(const_int 1)]))))]
   "TARGET_SSE2 && reload_completed"
   [(set (match_dup 0) (match_dup 1))]
-  "operands[0] = adjust_address (operands[0], DFmode, 8);")
+  "operands[0] = adjust_address (operands[0], DFmode, 0);")
 
 ;; Not sure these two are ever used, but it doesn't hurt to have
 ;; them. -aoliva
@@ -12095,7 +12052,7 @@
 	  (unspec:V8SF [(match_operand:V8HI 1 "register_operand" "x")]
 		       UNSPEC_VCVTPH2PS)
 	  (parallel [(const_int 0) (const_int 1)
-		     (const_int 1) (const_int 2)])))]
+		     (const_int 2) (const_int 3)])))]
   "TARGET_F16C"
   "vcvtph2ps\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
diff -Naur gcc-4.6.3.orig/gcc/config/ia64/linux-unwind.h gcc-4.6.3/gcc/config/ia64/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/ia64/linux-unwind.h	2009-08-14 20:49:40.000000000 +0000
+++ gcc-4.6.3/gcc/config/ia64/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for IA64 Linux.
-   Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2012 Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -47,7 +47,7 @@
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame_ = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame_->sc;
@@ -137,7 +137,7 @@
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame->sc;
diff -Naur gcc-4.6.3.orig/gcc/config/m32c/m32c.c gcc-4.6.3/gcc/config/m32c/m32c.c
--- gcc-4.6.3.orig/gcc/config/m32c/m32c.c	2011-02-10 19:41:26.000000000 +0000
+++ gcc-4.6.3/gcc/config/m32c/m32c.c	2012-03-29 02:15:29.973365000 +0000
@@ -447,7 +447,7 @@
     flag_ivopts = 0;
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   /* r8c/m16c have no 16-bit indirect call, so thunks are involved.
diff -Naur gcc-4.6.3.orig/gcc/config/mips/linux-unwind.h gcc-4.6.3/gcc/config/mips/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/mips/linux-unwind.h	2009-04-09 15:00:19.000000000 +0000
+++ gcc-4.6.3/gcc/config/mips/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,6 @@
 /* DWARF2 EH unwinding support for MIPS Linux.
-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2012 Free Software
+   Foundation, Inc.
 
 This file is part of GCC.
 
@@ -75,7 +76,7 @@
       struct rt_sigframe {
 	u_int32_t ass[4];  /* Argument save space for o32.  */
 	u_int32_t trampoline[2];
-	struct siginfo info;
+	siginfo_t info;
 	_sig_ucontext_t uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
diff -Naur gcc-4.6.3.orig/gcc/config/mn10300/mn10300.c gcc-4.6.3/gcc/config/mn10300/mn10300.c
--- gcc-4.6.3.orig/gcc/config/mn10300/mn10300.c	2011-02-15 17:09:39.000000000 +0000
+++ gcc-4.6.3/gcc/config/mn10300/mn10300.c	2012-07-06 10:09:28.333336000 +0000
@@ -2505,12 +2505,15 @@
    may access it using GOTOFF instead of GOT.  */
 
 static void
-mn10300_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
+mn10300_encode_section_info (tree decl, rtx rtl, int first)
 {
   rtx symbol;
 
+  default_encode_section_info (decl, rtl, first);
+
   if (! MEM_P (rtl))
     return;
+
   symbol = XEXP (rtl, 0);
   if (GET_CODE (symbol) != SYMBOL_REF)
     return;
diff -Naur gcc-4.6.3.orig/gcc/config/pa/linux-unwind.h gcc-4.6.3/gcc/config/pa/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/pa/linux-unwind.h	2009-12-05 17:45:59.000000000 +0000
+++ gcc-4.6.3/gcc/config/pa/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for PA Linux.
-   Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -63,7 +63,7 @@
   int i;
   struct sigcontext *sc;
   struct rt_sigframe {
-    struct siginfo info;
+    siginfo_t info;
     struct ucontext uc;
   } *frame;
 
diff -Naur gcc-4.6.3.orig/gcc/config/pa/pa-protos.h gcc-4.6.3/gcc/config/pa/pa-protos.h
--- gcc-4.6.3.orig/gcc/config/pa/pa-protos.h	2011-10-29 21:40:55.000000000 +0000
+++ gcc-4.6.3/gcc/config/pa/pa-protos.h	2012-03-12 17:08:20.095334000 +0000
@@ -136,6 +136,7 @@
 extern int cint_ok_for_move (HOST_WIDE_INT);
 extern void hppa_expand_prologue (void);
 extern void hppa_expand_epilogue (void);
+extern bool pa_can_use_return_insn (void);
 extern int ior_mask_p (unsigned HOST_WIDE_INT);
 extern void compute_zdepdi_operands (unsigned HOST_WIDE_INT,
 				     unsigned *);
diff -Naur gcc-4.6.3.orig/gcc/config/pa/pa.c gcc-4.6.3/gcc/config/pa/pa.c
--- gcc-4.6.3.orig/gcc/config/pa/pa.c	2011-10-29 21:40:55.000000000 +0000
+++ gcc-4.6.3/gcc/config/pa/pa.c	2012-06-17 01:33:06.931030000 +0000
@@ -185,6 +185,7 @@
 static void pa_conditional_register_usage (void);
 static enum machine_mode pa_c_mode_for_suffix (char);
 static section *pa_function_section (tree, enum node_frequency, bool, bool);
+static unsigned int pa_section_type_flags (tree, const char *, int);
 
 /* The following extra sections are only used for SOM.  */
 static GTY(()) section *som_readonly_data_section;
@@ -400,6 +401,9 @@
 #undef TARGET_ASM_FUNCTION_SECTION
 #define TARGET_ASM_FUNCTION_SECTION pa_function_section
 
+#undef TARGET_SECTION_TYPE_FLAGS
+#define TARGET_SECTION_TYPE_FLAGS pa_section_type_flags
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Parse the -mfixed-range= option string.  */
@@ -4442,6 +4446,24 @@
     }
 }
 
+bool
+pa_can_use_return_insn (void)
+{
+  if (!reload_completed)
+    return false;
+
+  if (frame_pointer_needed)
+    return false;
+
+  if (df_regs_ever_live_p (2))
+    return false;
+
+  if (crtl->profile)
+    return false;
+
+  return compute_frame_size (get_frame_size (), 0) == 0;
+}
+
 rtx
 hppa_pic_save_rtx (void)
 {
@@ -4586,7 +4608,7 @@
   rtx saved_rp;
   rtx ins;
 
-  /* Instruction stream at the normal return address for the export stub:
+  /* The instruction stream at the return address of a PA1.X export stub is:
 
 	0x4bc23fd1 | stub+8:   ldw -18(sr0,sp),rp
 	0x004010a1 | stub+12:  ldsid (sr0,rp),r1
@@ -4594,10 +4616,16 @@
 	0xe0400002 | stub+20:  be,n 0(sr0,rp)
 
      0xe0400002 must be specified as -532676606 so that it won't be
-     rejected as an invalid immediate operand on 64-bit hosts.  */
+     rejected as an invalid immediate operand on 64-bit hosts.
 
-  HOST_WIDE_INT insns[4] = {0x4bc23fd1, 0x004010a1, 0x00011820, -532676606};
-  int i;
+     The instruction stream at the return address of a PA2.0 export stub is:
+
+	0x4bc23fd1 | stub+8:   ldw -18(sr0,sp),rp
+	0xe840d002 | stub+12:  bve,n (rp)
+  */
+
+  HOST_WIDE_INT insns[4];
+  int i, len;
 
   if (count != 0)
     return NULL_RTX;
@@ -4620,11 +4648,26 @@
   ins = copy_to_reg (gen_rtx_AND (Pmode, rp, MASK_RETURN_ADDR));
   label = gen_label_rtx ();
 
+  if (TARGET_PA_20)
+    {
+      insns[0] = 0x4bc23fd1;
+      insns[1] = -398405630;
+      len = 2;
+    }
+  else
+    {
+      insns[0] = 0x4bc23fd1;
+      insns[1] = 0x004010a1;
+      insns[2] = 0x00011820;
+      insns[3] = -532676606;
+      len = 4;
+    }
+
   /* Check the instruction stream at the normal return address for the
      export stub.  If it is an export stub, than our return address is
      really in -24[frameaddr].  */
 
-  for (i = 0; i < 3; i++)
+  for (i = 0; i < len; i++)
     {
       rtx op0 = gen_rtx_MEM (SImode, plus_constant (ins, i * 4)); 
       rtx op1 = GEN_INT (insns[i]);
@@ -7501,7 +7544,7 @@
     return 24;
   else
     {
-      if (!TARGET_LONG_CALLS && distance < 240000)
+      if (!TARGET_LONG_CALLS && distance < MAX_PCREL17F_OFFSET)
 	return 8;
 
       if (TARGET_LONG_ABS_CALL && !flag_pic)
@@ -7714,7 +7757,7 @@
   /* pc-relative branch.  */
   if (!TARGET_LONG_CALLS
       && ((TARGET_PA_20 && !sibcall && distance < 7600000)
-	  || distance < 240000))
+	  || distance < MAX_PCREL17F_OFFSET))
     length += 8;
 
   /* 64-bit plabel sequence.  */
@@ -8073,7 +8116,7 @@
   if (TARGET_FAST_INDIRECT_CALLS
       || (!TARGET_PORTABLE_RUNTIME
 	  && ((TARGET_PA_20 && !TARGET_SOM && distance < 7600000)
-	      || distance < 240000)))
+	      || distance < MAX_PCREL17F_OFFSET)))
     return 8;
 
   if (flag_pic)
@@ -10392,4 +10435,23 @@
   return default_function_section (decl, freq, startup, exit);
 }
 
+/* Implement TARGET_SECTION_TYPE_FLAGS.  */
+
+static unsigned int
+pa_section_type_flags (tree decl, const char *name, int reloc)
+{
+  unsigned int flags;
+
+  flags = default_section_type_flags (decl, name, reloc);
+
+  /* Function labels are placed in the constant pool.  This can
+     cause a section conflict if decls are put in ".data.rel.ro"
+     or ".data.rel.ro.local" using the __attribute__ construct.  */
+  if (strcmp (name, ".data.rel.ro") == 0
+      || strcmp (name, ".data.rel.ro.local") == 0)
+    flags |= SECTION_WRITE | SECTION_RELRO;
+
+  return flags;
+}
+
 #include "gt-pa.h"
diff -Naur gcc-4.6.3.orig/gcc/config/pa/pa.h gcc-4.6.3/gcc/config/pa/pa.h
--- gcc-4.6.3.orig/gcc/config/pa/pa.h	2011-10-29 20:19:38.000000000 +0000
+++ gcc-4.6.3/gcc/config/pa/pa.h	2012-06-17 01:33:06.931030000 +0000
@@ -1563,3 +1563,12 @@
 #undef TARGET_HAVE_TLS
 #define TARGET_HAVE_TLS true
 #endif
+
+/* The maximum offset in bytes for a PA 1.X pc-relative call to the
+   head of the preceding stub table.  The selected offsets have been
+   chosen so that approximately one call stub is allocated for every
+   86.7 instructions.  A long branch stub is two instructions when
+   not generating PIC code.  For HP-UX and ELF targets, PIC stubs are
+   seven and four instructions, respectively.  */  
+#define MAX_PCREL17F_OFFSET \
+  (flag_pic ? (TARGET_HPUX ? 198164 : 221312) : 240000)
diff -Naur gcc-4.6.3.orig/gcc/config/pa/pa.md gcc-4.6.3/gcc/config/pa/pa.md
--- gcc-4.6.3.orig/gcc/config/pa/pa.md	2011-10-29 21:40:55.000000000 +0000
+++ gcc-4.6.3/gcc/config/pa/pa.md	2012-03-12 17:08:20.095334000 +0000
@@ -6348,7 +6348,7 @@
   ""
   "*
 {
-  int x = INTVAL (operands[1]);
+  unsigned HOST_WIDE_INT x = UINTVAL (operands[1]);
   operands[2] = GEN_INT (4 + exact_log2 ((x >> 4) + 1));
   operands[1] = GEN_INT ((x & 0xf) - 0x10);
   return \"{zvdepi %1,%2,%0|depwi,z %1,%%sar,%2,%0}\";
@@ -6366,7 +6366,7 @@
   "exact_log2 (INTVAL (operands[1]) + 1) > 0"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 (x + 1));
   return \"{vdepi -1,%2,%0|depwi -1,%%sar,%2,%0}\";
 }"
@@ -6383,7 +6383,7 @@
   "INTVAL (operands[1]) == -2"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 ((~x) + 1));
   return \"{vdepi 0,%2,%0|depwi 0,%%sar,%2,%0}\";
 }"
@@ -6447,7 +6447,7 @@
   "TARGET_64BIT"
   "*
 {
-  int x = INTVAL (operands[1]);
+  unsigned HOST_WIDE_INT x = UINTVAL (operands[1]);
   operands[2] = GEN_INT (4 + exact_log2 ((x >> 4) + 1));
   operands[1] = GEN_INT ((x & 0x1f) - 0x20);
   return \"depdi,z %1,%%sar,%2,%0\";
@@ -6465,7 +6465,7 @@
   "TARGET_64BIT && exact_log2 (INTVAL (operands[1]) + 1) > 0"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 (x + 1));
   return \"depdi -1,%%sar,%2,%0\";
 }"
@@ -6482,7 +6482,7 @@
   "TARGET_64BIT && INTVAL (operands[1]) == -2"
   "*
 {
-  int x = INTVAL (operands[1]);
+  HOST_WIDE_INT x = INTVAL (operands[1]);
   operands[2] = GEN_INT (exact_log2 ((~x) + 1));
   return \"depdi 0,%%sar,%2,%0\";
 }"
@@ -6671,6 +6671,20 @@
 
 ;; Unconditional and other jump instructions.
 
+;; Trivial return used when no epilogue is needed.
+(define_insn "return"
+  [(return)
+   (use (reg:SI 2))]
+  "pa_can_use_return_insn ()"
+  "*
+{
+  if (TARGET_PA_20)
+    return \"bve%* (%%r2)\";
+  return \"bv%* %%r0(%%r2)\";
+}"
+  [(set_attr "type" "branch")
+   (set_attr "length" "4")])
+
 ;; This is used for most returns.
 (define_insn "return_internal"
   [(return)
@@ -6719,11 +6733,8 @@
   rtx x;
 
   /* Try to use the trivial return first.  Else use the full epilogue.  */
-  if (reload_completed
-      && !frame_pointer_needed
-      && !df_regs_ever_live_p (2)
-      && (compute_frame_size (get_frame_size (), 0) ? 0 : 1))
-    x = gen_return_internal ();
+  if (pa_can_use_return_insn ())
+    x = gen_return ();
   else
     {
       hppa_expand_epilogue ();
diff -Naur gcc-4.6.3.orig/gcc/config/pa/predicates.md gcc-4.6.3/gcc/config/pa/predicates.md
--- gcc-4.6.3.orig/gcc/config/pa/predicates.md	2011-04-20 23:36:20.000000000 +0000
+++ gcc-4.6.3/gcc/config/pa/predicates.md	2012-03-04 16:23:26.705142000 +0000
@@ -421,9 +421,9 @@
   (ior (match_operand 0 "register_operand")
        (match_operand 0 "cint_ior_operand")))
 
-;; True iff OP is a CONST_INT of the forms 0...0xxxx or
-;; 0...01...1xxxx. Such values can be the left hand side x in (x <<
-;; r), using the zvdepi instruction.
+;; True iff OP is a CONST_INT of the forms 0...0xxxx, 0...01...1xxxx,
+;; or 1...1xxxx. Such values can be the left hand side x in (x << r),
+;; using the zvdepi instruction.
 
 (define_predicate "lhs_lshift_cint_operand"
   (match_code "const_int")
diff -Naur gcc-4.6.3.orig/gcc/config/rs6000/altivec.md gcc-4.6.3/gcc/config/rs6000/altivec.md
--- gcc-4.6.3.orig/gcc/config/rs6000/altivec.md	2011-07-08 20:10:18.000000000 +0000
+++ gcc-4.6.3/gcc/config/rs6000/altivec.md	2012-06-04 17:42:25.267281000 +0000
@@ -2394,8 +2394,8 @@
 
 (define_insn "altivec_stvlx"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVLX)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvlx %1,%y0"
@@ -2403,8 +2403,8 @@
 
 (define_insn "altivec_stvlxl"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVLXL)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvlxl %1,%y0"
@@ -2412,8 +2412,8 @@
 
 (define_insn "altivec_stvrx"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVRX)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvrx %1,%y0"
@@ -2421,8 +2421,8 @@
 
 (define_insn "altivec_stvrxl"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+	  (match_operand:V16QI 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVRXL)])]
   "TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL"
   "stvrxl %1,%y0"
diff -Naur gcc-4.6.3.orig/gcc/config/rs6000/rs6000.c gcc-4.6.3/gcc/config/rs6000/rs6000.c
--- gcc-4.6.3.orig/gcc/config/rs6000/rs6000.c	2012-02-15 21:17:42.000000000 +0000
+++ gcc-4.6.3/gcc/config/rs6000/rs6000.c	2012-05-24 13:52:56.478084000 +0000
@@ -3695,12 +3695,23 @@
       case vec_to_scalar:
       case scalar_to_vec:
       case cond_branch_not_taken:
-      case vec_perm:
         return 1;
 
       case cond_branch_taken:
         return 3;
 
+      case vec_perm:
+	if (TARGET_VSX)
+	  return 4;
+	else
+	  return 1;
+
+      case vec_promote_demote:
+	if (TARGET_VSX)
+	  return 5;
+	else
+	  return 1;
+
       case unaligned_load:
         if (TARGET_VSX && TARGET_ALLOW_MOVMISALIGN)
           {
@@ -15811,7 +15822,6 @@
 print_operand (FILE *file, rtx x, int code)
 {
   int i;
-  HOST_WIDE_INT val;
   unsigned HOST_WIDE_INT uval;
 
   switch (code)
@@ -16252,34 +16262,17 @@
 
     case 'W':
       /* MB value for a PowerPC64 rldic operand.  */
-      val = (GET_CODE (x) == CONST_INT
-	     ? INTVAL (x) : CONST_DOUBLE_HIGH (x));
-
-      if (val < 0)
-	i = -1;
-      else
-	for (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)
-	  if ((val <<= 1) < 0)
-	    break;
+      i = clz_hwi (GET_CODE (x) == CONST_INT
+		   ? INTVAL (x) : CONST_DOUBLE_HIGH (x));
 
 #if HOST_BITS_PER_WIDE_INT == 32
-      if (GET_CODE (x) == CONST_INT && i >= 0)
+      if (GET_CODE (x) == CONST_INT && i > 0)
 	i += 32;  /* zero-extend high-part was all 0's */
       else if (GET_CODE (x) == CONST_DOUBLE && i == 32)
-	{
-	  val = CONST_DOUBLE_LOW (x);
-
-	  gcc_assert (val);
-	  if (val < 0)
-	    --i;
-	  else
-	    for ( ; i < 64; i++)
-	      if ((val <<= 1) < 0)
-		break;
-	}
+	i = clz_hwi (CONST_DOUBLE_LOW (x)) + 32;
 #endif
 
-      fprintf (file, "%d", i + 1);
+      fprintf (file, "%d", i);
       return;
 
     case 'x':
@@ -17229,6 +17222,10 @@
     case EQ:
     case GT:
     case GTU:
+    case ORDERED:
+    case UNORDERED:
+    case UNEQ:
+    case LTGT:
       mask = gen_reg_rtx (mode);
       emit_insn (gen_rtx_SET (VOIDmode,
 			      mask,
diff -Naur gcc-4.6.3.orig/gcc/config/rs6000/rs6000.h gcc-4.6.3/gcc/config/rs6000/rs6000.h
--- gcc-4.6.3.orig/gcc/config/rs6000/rs6000.h	2011-07-27 18:17:15.000000000 +0000
+++ gcc-4.6.3/gcc/config/rs6000/rs6000.h	2012-04-13 21:55:15.746111000 +0000
@@ -469,10 +469,11 @@
 /* ISA 2.01 allowed FCFID to be done in 32-bit, previously it was 64-bit only.
    Enable 32-bit fcfid's on any of the switches for newer ISA machines or
    XILINX.  */
-#define TARGET_FCFID	(TARGET_POWERPC64 \
-			 || TARGET_POPCNTB	/* ISA 2.02 */ \
-			 || TARGET_CMPB		/* ISA 2.05 */ \
-			 || TARGET_POPCNTD	/* ISA 2.06 */ \
+#define TARGET_FCFID	(TARGET_POWERPC64				\
+			 || TARGET_PPC_GPOPT	/* 970/power4 */	\
+			 || TARGET_POPCNTB	/* ISA 2.02 */		\
+			 || TARGET_CMPB		/* ISA 2.05 */		\
+			 || TARGET_POPCNTD	/* ISA 2.06 */		\
 			 || TARGET_XILINX_FPU)
 
 #define TARGET_FCTIDZ	TARGET_FCFID
diff -Naur gcc-4.6.3.orig/gcc/config/rs6000/rs6000.md gcc-4.6.3/gcc/config/rs6000/rs6000.md
--- gcc-4.6.3.orig/gcc/config/rs6000/rs6000.md	2012-01-18 19:14:48.000000000 +0000
+++ gcc-4.6.3/gcc/config/rs6000/rs6000.md	2012-05-04 00:31:50.505528000 +0000
@@ -2524,7 +2524,18 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
+    }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
     }
   else
     {
@@ -2574,7 +2585,18 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));
+    }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
     }
   else
     {
@@ -2655,7 +2677,18 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
+    }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
     }
   else
     {
@@ -2700,7 +2733,18 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
+      if (TARGET_AVOID_XFORM)
+	{
+	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
+	  addr2 = op2;
+	}
+      else
+	addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
+    }
+  else if (TARGET_AVOID_XFORM)
+    {
+      emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
+      addr2 = op2;
     }
   else
     {
diff -Naur gcc-4.6.3.orig/gcc/config/rs6000/vector.md gcc-4.6.3/gcc/config/rs6000/vector.md
--- gcc-4.6.3.orig/gcc/config/rs6000/vector.md	2011-07-08 20:10:18.000000000 +0000
+++ gcc-4.6.3/gcc/config/rs6000/vector.md	2012-03-06 19:46:28.829628000 +0000
@@ -448,6 +448,94 @@
   "VECTOR_UNIT_ALTIVEC_P (<MODE>mode)"
   "")
 
+(define_insn_and_split "*vector_uneq<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(uneq:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+		    (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(gt:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(gt:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(not:VEC_F (ior:VEC_F (match_dup 3)
+			      (match_dup 4))))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
+(define_insn_and_split "*vector_ltgt<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(ltgt:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+		    (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(gt:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(gt:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(ior:VEC_F (match_dup 3)
+		   (match_dup 4)))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
+(define_insn_and_split "*vector_ordered<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(ordered:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+		       (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(ge:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(ge:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(ior:VEC_F (match_dup 3)
+		   (match_dup 4)))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
+(define_insn_and_split "*vector_unordered<mode>"
+  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
+	(unordered:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
+			 (match_operand:VEC_F 2 "vfloat_operand" "")))]
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "#"
+  ""
+  [(set (match_dup 3)
+	(ge:VEC_F (match_dup 1)
+		  (match_dup 2)))
+   (set (match_dup 4)
+	(ge:VEC_F (match_dup 2)
+		  (match_dup 1)))
+   (set (match_dup 0)
+	(not:VEC_F (ior:VEC_F (match_dup 3)
+			      (match_dup 4))))]
+  "
+{
+  operands[3] = gen_reg_rtx (<MODE>mode);
+  operands[4] = gen_reg_rtx (<MODE>mode);
+}")
+
 ;; Note the arguments for __builtin_altivec_vsel are op2, op1, mask
 ;; which is in the reverse order that we want
 (define_expand "vector_select_<mode>"
diff -Naur gcc-4.6.3.orig/gcc/config/rs6000/vsx.md gcc-4.6.3/gcc/config/rs6000/vsx.md
--- gcc-4.6.3.orig/gcc/config/rs6000/vsx.md	2011-07-08 20:10:18.000000000 +0000
+++ gcc-4.6.3/gcc/config/rs6000/vsx.md	2012-03-02 22:12:52.237313000 +0000
@@ -1006,9 +1006,9 @@
   "VECTOR_MEM_VSX_P (<MODE>mode)"
 {
   if (INTVAL (operands[3]) == 0)
-    return \"xxpermdi %x0,%x1,%x2,1\";
+    return \"xxpermdi %x0,%x2,%x1,1\";
   else if (INTVAL (operands[3]) == 1)
-    return \"xxpermdi %x0,%x2,%x1,0\";
+    return \"xxpermdi %x0,%x1,%x2,0\";
   else
     gcc_unreachable ();
 }
diff -Naur gcc-4.6.3.orig/gcc/config/rx/rx.c gcc-4.6.3/gcc/config/rx/rx.c
--- gcc-4.6.3.orig/gcc/config/rx/rx.c	2011-05-17 08:59:10.000000000 +0000
+++ gcc-4.6.3/gcc/config/rx/rx.c	2012-03-29 02:15:29.973365000 +0000
@@ -2348,7 +2348,7 @@
 rx_option_override (void)
 {
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   rx_override_options_after_change ();
diff -Naur gcc-4.6.3.orig/gcc/config/sh/linux-unwind.h gcc-4.6.3/gcc/config/sh/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/sh/linux-unwind.h	2009-04-09 15:00:19.000000000 +0000
+++ gcc-4.6.3/gcc/config/sh/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,6 @@
 /* DWARF2 EH unwinding support for SH Linux.
-   Copyright (C) 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2006, 2007, 2009, 2012 Free Software Foundation,
+   Inc.
 
 This file is part of GCC.
 
@@ -80,9 +81,9 @@
 	   && (*(unsigned long *) (pc+11)  == 0x6ff0fff0))
     {
       struct rt_sigframe {
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
@@ -179,7 +180,7 @@
 		&& (*(unsigned short *) (pc+14)  == 0x00ad))))
     {
       struct rt_sigframe {
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
diff -Naur gcc-4.6.3.orig/gcc/config/sh/sh.c gcc-4.6.3/gcc/config/sh/sh.c
--- gcc-4.6.3.orig/gcc/config/sh/sh.c	2011-06-08 04:07:25.000000000 +0000
+++ gcc-4.6.3/gcc/config/sh/sh.c	2012-07-22 23:49:56.312817000 +0000
@@ -763,11 +763,6 @@
   SUBTARGET_OVERRIDE_OPTIONS;
   if (optimize > 1 && !optimize_size)
     target_flags |= MASK_SAVE_ALL_TARGET_REGS;
-  if (flag_finite_math_only == 2)
-    flag_finite_math_only
-      = !flag_signaling_nans && TARGET_SH2E && ! TARGET_IEEE;
-  if (TARGET_SH2E && !flag_finite_math_only)
-    target_flags |= MASK_IEEE;
   sh_cpu = PROCESSOR_SH1;
   assembler_dialect = 0;
   if (TARGET_SH2)
@@ -911,8 +906,6 @@
     if (! VALID_REGISTER_P (ADDREGNAMES_REGNO (regno)))
       sh_additional_register_names[regno][0] = '\0';
 
-  flag_omit_frame_pointer = (PREFERRED_DEBUGGING_TYPE == DWARF2_DEBUG);
-
   if ((flag_pic && ! TARGET_PREFERGOT)
       || (TARGET_SHMEDIA && !TARGET_PT_FIXED))
     flag_no_function_cse = 1;
@@ -944,22 +937,17 @@
 	flag_schedule_insns = 0;
     }
 
-    if ((target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS) == 0)
-       target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
-
   /* Unwind info is not correct around the CFG unless either a frame 
      pointer is present or M_A_O_A is set.  Fixing this requires rewriting 
      unwind info generation to be aware of the CFG and propagating states 
      around edges.  */
   if ((flag_unwind_tables || flag_asynchronous_unwind_tables
        || flag_exceptions || flag_non_call_exceptions)   
-      && flag_omit_frame_pointer
-      && !(target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))
+      && flag_omit_frame_pointer && !TARGET_ACCUMULATE_OUTGOING_ARGS)
     {
-      if (target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS)
 	warning (0, "unwind tables currently require either a frame pointer "
 		 "or -maccumulate-outgoing-args for correctness");
-      target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
+	TARGET_ACCUMULATE_OUTGOING_ARGS = 1;
     }
 
   /* Unwinding with -freorder-blocks-and-partition does not work on this
@@ -1014,11 +1002,16 @@
 	align_functions = min_align;
     }
 
+  /* If the -mieee option was not explicitly set by the user, turn it on
+     unless -ffinite-math-only was specified.  See also PR 33135.  */
+  if (! global_options_set.x_TARGET_IEEE)
+    TARGET_IEEE = ! flag_finite_math_only;
+
   if (sh_fixed_range_str)
     sh_fix_range (sh_fixed_range_str);
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 }
 
diff -Naur gcc-4.6.3.orig/gcc/config/sh/sh.opt gcc-4.6.3/gcc/config/sh/sh.opt
--- gcc-4.6.3.orig/gcc/config/sh/sh.opt	2010-10-22 12:14:45.000000000 +0000
+++ gcc-4.6.3/gcc/config/sh/sh.opt	2012-07-22 23:49:56.312817000 +0000
@@ -202,7 +202,7 @@
 Generate FPU-less SHcompact code
 
 maccumulate-outgoing-args
-Target Report Mask(ACCUMULATE_OUTGOING_ARGS)
+Target Report Var(TARGET_ACCUMULATE_OUTGOING_ARGS) Init(1)
 Reserve space for outgoing arguments in the function prologue
 
 madjust-unroll
@@ -270,8 +270,8 @@
 Follow Renesas (formerly Hitachi) / SuperH calling conventions
 
 mieee
-Target Report Mask(IEEE)
-Increase the IEEE compliance for floating-point code
+Target Var(TARGET_IEEE)
+Increase the IEEE compliance for floating-point comparisons
 
 mindexed-addressing
 Target Report Mask(ALLOW_INDEXED_ADDRESS) Condition(SUPPORT_ANY_SH5_32MEDIA)
diff -Naur gcc-4.6.3.orig/gcc/config/sol2.h gcc-4.6.3/gcc/config/sol2.h
--- gcc-4.6.3.orig/gcc/config/sol2.h	2011-07-15 09:39:41.000000000 +0000
+++ gcc-4.6.3/gcc/config/sol2.h	2012-08-16 13:21:11.398440000 +0000
@@ -1,6 +1,6 @@
 /* Operating system specific defines to be used when targeting GCC for any
    Solaris 2 system.
-   Copyright 2002, 2003, 2004, 2007, 2008, 2009, 2010, 2011
+   Copyright 2002, 2003, 2004, 2007, 2008, 2009, 2010, 2011, 2012
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -163,12 +163,12 @@
    %{YP,*} \
    %{R*} \
    %{compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib} \
-             %{!p:%{!pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib:%R/usr/lib}}} \
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib:%R/lib} \
+             %{!p:%{!pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib:%R/usr/lib:%R/lib}}} \
              -R %R/usr/ucblib} \
    %{!compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib} \
-             %{!p:%{!pg:-Y P,%R/usr/ccs/lib:%R/usr/lib}}}}"
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib:%R/lib} \
+             %{!p:%{!pg:-Y P,%R/usr/ccs/lib:%R/usr/lib:%R/lib}}}}"
 
 #undef LINK_ARCH32_SPEC
 #define LINK_ARCH32_SPEC LINK_ARCH32_SPEC_BASE
diff -Naur gcc-4.6.3.orig/gcc/config/sparc/sol2-bi.h gcc-4.6.3/gcc/config/sparc/sol2-bi.h
--- gcc-4.6.3.orig/gcc/config/sparc/sol2-bi.h	2011-02-17 13:57:21.000000000 +0000
+++ gcc-4.6.3/gcc/config/sparc/sol2-bi.h	2012-08-16 13:21:11.398440000 +0000
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GCC, for bi-arch SPARC
    running Solaris 2 using the system assembler and linker.
-   Copyright (C) 2002, 2003, 2004, 2006, 2007, 2009, 2010, 2011
+   Copyright (C) 2002, 2003, 2004, 2006, 2007, 2009, 2010, 2011, 2012
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -191,12 +191,12 @@
    %{YP,*} \
    %{R*} \
    %{compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9} \
-       %{!p:%{!pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/sparcv9}}} \
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9:%R/lib/sparcv9} \
+       %{!p:%{!pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/sparcv9:%R/lib/sparcv9}}} \
      -R %R/usr/ucblib/sparcv9} \
    %{!compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9} \
-       %{!p:%{!pg:-Y P,%R/usr/lib/sparcv9}}}}"
+     %{!YP,*:%{p|pg:-Y P,%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9:%R/lib/sparcv9} \
+       %{!p:%{!pg:-Y P,%R/usr/lib/sparcv9:%R/lib/sparcv9}}}}"
 
 #define LINK_ARCH64_SPEC LINK_ARCH64_SPEC_BASE
 
diff -Naur gcc-4.6.3.orig/gcc/config/sparc/sparc.c gcc-4.6.3/gcc/config/sparc/sparc.c
--- gcc-4.6.3.orig/gcc/config/sparc/sparc.c	2011-12-16 23:38:34.000000000 +0000
+++ gcc-4.6.3/gcc/config/sparc/sparc.c	2012-04-09 08:53:49.126746000 +0000
@@ -3658,13 +3658,17 @@
 {
   x = delegitimize_mem_from_attrs (x);
 
-  if (GET_CODE (x) == LO_SUM
-      && GET_CODE (XEXP (x, 1)) == UNSPEC
-      && XINT (XEXP (x, 1), 1) == UNSPEC_TLSLE)
-    {
-      x = XVECEXP (XEXP (x, 1), 0, 0);
-      gcc_assert (GET_CODE (x) == SYMBOL_REF);
-    }
+  if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 1)) == UNSPEC)
+    switch (XINT (XEXP (x, 1), 1))
+      {
+      case UNSPEC_MOVE_PIC:
+      case UNSPEC_TLSLE:
+	x = XVECEXP (XEXP (x, 1), 0, 0);
+	gcc_assert (GET_CODE (x) == SYMBOL_REF);
+	break;
+      default:
+	break;
+      }
 
   return x;
 }
@@ -9634,6 +9638,7 @@
 						       void_list_node));
 	  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
 					   NULL_TREE, void_type_node);
+	  TREE_PUBLIC (decl) = 1;
 	  TREE_STATIC (decl) = 1;
 	  make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));
 	  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
diff -Naur gcc-4.6.3.orig/gcc/config/spu/spu.c gcc-4.6.3/gcc/config/spu/spu.c
--- gcc-4.6.3.orig/gcc/config/spu/spu.c	2011-07-15 12:33:27.000000000 +0000
+++ gcc-4.6.3/gcc/config/spu/spu.c	2012-03-02 14:51:58.551861000 +0000
@@ -6794,6 +6794,7 @@
       case scalar_to_vec:
       case cond_branch_not_taken:
       case vec_perm:
+      case vec_promote_demote:
         return 1;
 
       case scalar_store:
diff -Naur gcc-4.6.3.orig/gcc/config/xtensa/linux-unwind.h gcc-4.6.3/gcc/config/xtensa/linux-unwind.h
--- gcc-4.6.3.orig/gcc/config/xtensa/linux-unwind.h	2009-04-09 15:00:19.000000000 +0000
+++ gcc-4.6.3/gcc/config/xtensa/linux-unwind.h	2012-04-20 08:08:13.688436000 +0000
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Xtensa.
-   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -62,7 +62,7 @@
   struct sigcontext *sc;
 
   struct rt_sigframe {
-    struct siginfo info;
+    siginfo_t info;
     struct ucontext uc;
   } *rt_;
 
diff -Naur gcc-4.6.3.orig/gcc/config.gcc gcc-4.6.3/gcc/config.gcc
--- gcc-4.6.3.orig/gcc/config.gcc	2011-07-22 16:44:50.000000000 +0000
+++ gcc-4.6.3/gcc/config.gcc	2012-06-04 09:53:04.873173000 +0000
@@ -817,7 +817,7 @@
 arm*-*-linux*)			# ARM GNU/Linux with ELF
 	tm_file="dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h arm/elf.h arm/linux-gas.h arm/linux-elf.h"
 	case $target in
-	arm*b-*)
+	arm*b-*-linux*)
 		tm_defines="${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1"
 		;;
 	esac
@@ -925,7 +925,7 @@
 	extra_objs="avr-devices.o"
 	;;
 avr-*-*)
-	tm_file="avr/avr.h dbxelf.h newlib-stdint.h"
+	tm_file="avr/avr.h dbxelf.h avr/avr-stdint.h"
 	use_gcc_stdint=wrap
 	extra_gcc_objs="driver-avr.o avr-devices.o"
 	extra_objs="avr-devices.o"
diff -Naur gcc-4.6.3.orig/gcc/configure gcc-4.6.3/gcc/configure
--- gcc-4.6.3.orig/gcc/configure	2011-11-20 21:24:07.000000000 +0000
+++ gcc-4.6.3/gcc/configure	2012-05-16 09:19:25.461438000 +0000
@@ -4842,7 +4842,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_cc_gcc_supports_ada" >&5
 $as_echo "$acx_cv_cc_gcc_supports_ada" >&6; }
 
-if test x$GNATBIND != xno && test x$GNATMAKE != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
+if test "x$GNATBIND" != xno && test "x$GNATMAKE" != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
   have_gnat=yes
 else
   have_gnat=no
diff -Naur gcc-4.6.3.orig/gcc/convert.c gcc-4.6.3/gcc/convert.c
--- gcc-4.6.3.orig/gcc/convert.c	2011-10-12 11:57:36.000000000 +0000
+++ gcc-4.6.3/gcc/convert.c	2012-05-22 09:17:42.260176000 +0000
@@ -44,11 +44,6 @@
   if (TREE_TYPE (expr) == type)
     return expr;
 
-  /* Propagate overflow to the NULL pointer.  */
-  if (integer_zerop (expr))
-    return force_fit_type_double (type, double_int_zero, 0,
-				  TREE_OVERFLOW (expr));
-
   switch (TREE_CODE (TREE_TYPE (expr)))
     {
     case POINTER_TYPE:
diff -Naur gcc-4.6.3.orig/gcc/cp/decl.c gcc-4.6.3/gcc/cp/decl.c
--- gcc-4.6.3.orig/gcc/cp/decl.c	2012-02-14 23:34:34.000000000 +0000
+++ gcc-4.6.3/gcc/cp/decl.c	2012-04-04 20:48:59.830836000 +0000
@@ -3636,7 +3636,7 @@
     TYPE_SIZE_UNIT (nullptr_type_node) = size_int (GET_MODE_SIZE (ptr_mode));
     TYPE_UNSIGNED (nullptr_type_node) = 1;
     TYPE_PRECISION (nullptr_type_node) = GET_MODE_BITSIZE (ptr_mode);
-    SET_TYPE_MODE (nullptr_type_node, Pmode);
+    SET_TYPE_MODE (nullptr_type_node, ptr_mode);
     record_builtin_type (RID_MAX, "decltype(nullptr)", nullptr_type_node);
     nullptr_node = build_int_cst (nullptr_type_node, 0);
   }
diff -Naur gcc-4.6.3.orig/gcc/cp/pt.c gcc-4.6.3/gcc/cp/pt.c
--- gcc-4.6.3.orig/gcc/cp/pt.c	2012-02-14 23:36:19.000000000 +0000
+++ gcc-4.6.3/gcc/cp/pt.c	2012-04-03 22:51:08.968182000 +0000
@@ -17785,6 +17785,7 @@
             }
           else
             {
+	      tree tmp;
               decl = tsubst_copy (TREE_PURPOSE (t), argvec, 
                                   tf_warning_or_error, NULL_TREE);
 
@@ -17793,10 +17794,17 @@
                 in_base_initializer = 1;
 
 	      init = TREE_VALUE (t);
+	      tmp = init;
 	      if (init != void_type_node)
 		init = tsubst_expr (init, argvec,
 				    tf_warning_or_error, NULL_TREE,
 				    /*integral_constant_expression_p=*/false);
+	      if (init == NULL_TREE && tmp != NULL_TREE)
+		/* If we had an initializer but it instantiated to nothing,
+		   value-initialize the object.  This will only occur when
+		   the initializer was a pack expansion where the parameter
+		   packs used in that expansion were of length zero.  */
+		init = void_type_node;
               in_base_initializer = 0;
             }
 
diff -Naur gcc-4.6.3.orig/gcc/cp/semantics.c gcc-4.6.3/gcc/cp/semantics.c
--- gcc-4.6.3.orig/gcc/cp/semantics.c	2012-02-09 17:17:36.000000000 +0000
+++ gcc-4.6.3/gcc/cp/semantics.c	2012-04-03 22:50:13.736130000 +0000
@@ -6763,7 +6763,6 @@
 
   STRIP_NOPS (sub);
   subtype = TREE_TYPE (sub);
-  gcc_assert (POINTER_TYPE_P (subtype));
 
   if (TREE_CODE (sub) == ADDR_EXPR)
     {
diff -Naur gcc-4.6.3.orig/gcc/cp/typeck.c gcc-4.6.3/gcc/cp/typeck.c
--- gcc-4.6.3.orig/gcc/cp/typeck.c	2012-01-16 21:34:26.000000000 +0000
+++ gcc-4.6.3/gcc/cp/typeck.c	2012-06-25 20:37:14.416810000 +0000
@@ -1822,7 +1822,7 @@
   if (error_operand_p (exp))
     return error_mark_node;
 
-  if (NULLPTR_TYPE_P (type))
+  if (NULLPTR_TYPE_P (type) && !TREE_SIDE_EFFECTS (exp))
     return nullptr_node;
 
   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.
diff -Naur gcc-4.6.3.orig/gcc/df-problems.c gcc-4.6.3/gcc/df-problems.c
--- gcc-4.6.3.orig/gcc/df-problems.c	2011-07-07 19:10:01.000000000 +0000
+++ gcc-4.6.3/gcc/df-problems.c	2012-07-16 09:36:04.162835000 +0000
@@ -3956,6 +3956,19 @@
   df_simulate_initialize_backwards (merge_bb, test_use);
   for (insn = across_to; ; insn = next)
     {
+      if (CALL_P (insn))
+	{
+	  if (RTL_CONST_OR_PURE_CALL_P (insn))
+	    /* Pure functions can read from memory.  Const functions can
+	       read from arguments that the ABI has forced onto the stack.
+	       Neither sort of read can be volatile.  */
+	    memrefs_in_across |= MEMREF_NORMAL;
+	  else
+	    {
+	      memrefs_in_across |= MEMREF_VOLATILE;
+	      mem_sets_in_across |= MEMREF_VOLATILE;
+	    }
+	}
       if (NONDEBUG_INSN_P (insn))
 	{
 	  df_simulate_find_defs (insn, test_set);
diff -Naur gcc-4.6.3.orig/gcc/doc/install.texi gcc-4.6.3/gcc/doc/install.texi
--- gcc-4.6.3.orig/gcc/doc/install.texi	2011-03-21 12:13:26.000000000 +0000
+++ gcc-4.6.3/gcc/doc/install.texi	2012-04-06 08:28:56.865123000 +0000
@@ -1208,7 +1208,7 @@
 
 @item --with-llsc
 On MIPS targets, make @option{-mllsc} the default when no
-@option{-mno-lsc} option is passed.  This is the default for
+@option{-mno-llsc} option is passed.  This is the default for
 Linux-based targets, as the kernel will emulate them if the ISA does
 not provide them.
 
diff -Naur gcc-4.6.3.orig/gcc/doc/invoke.texi gcc-4.6.3/gcc/doc/invoke.texi
--- gcc-4.6.3.orig/gcc/doc/invoke.texi	2012-01-03 16:43:38.000000000 +0000
+++ gcc-4.6.3/gcc/doc/invoke.texi	2012-07-22 23:49:56.312817000 +0000
@@ -853,8 +853,8 @@
 -m5-compact  -m5-compact-nofpu @gol
 -mb  -ml  -mdalign  -mrelax @gol
 -mbigtable -mfmovd -mhitachi -mrenesas -mno-renesas -mnomacsave @gol
--mieee  -mbitops  -misize  -minline-ic_invalidate -mpadstruct  -mspace @gol
--mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
+-mieee -mno-ieee -mbitops  -misize  -minline-ic_invalidate -mpadstruct @gol
+-mspace -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
 -mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol
 -madjust-unroll -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol
 -maccumulate-outgoing-args -minvalid-symbols}
@@ -16938,13 +16938,15 @@
 @option{-mhitachi} is given.
 
 @item -mieee
+@item -mno-ieee
 @opindex mieee
-Increase IEEE-compliance of floating-point code.
-At the moment, this is equivalent to @option{-fno-finite-math-only}.
-When generating 16 bit SH opcodes, getting IEEE-conforming results for
-comparisons of NANs / infinities incurs extra overhead in every
-floating point comparison, therefore the default is set to
-@option{-ffinite-math-only}.
+@opindex mnoieee
+Control the IEEE compliance of floating-point comparisons, which affects the
+handling of cases where the result of a comparison is unordered.  By default
+@option{-mieee} is implicitly enabled.  If @option{-ffinite-math-only} is
+enabled @option{-mno-ieee} is implicitly set, which results in faster
+floating-point greater-equal and less-equal comparisons.  The implcit settings
+can be overridden by specifying either @option{-mieee} or @option{-mno-ieee}.
 
 @item -minline-ic_invalidate
 @opindex minline-ic_invalidate
diff -Naur gcc-4.6.3.orig/gcc/doc/tm.texi gcc-4.6.3/gcc/doc/tm.texi
--- gcc-4.6.3.orig/gcc/doc/tm.texi	2011-06-04 10:15:48.000000000 +0000
+++ gcc-4.6.3/gcc/doc/tm.texi	2012-08-10 13:26:44.694722000 +0000
@@ -1118,6 +1118,14 @@
 If the value of this macro has a type, it should be an unsigned type.
 @end defmac
 
+@deftypefn {Target Hook} HOST_WIDE_INT TARGET_VECTOR_ALIGNMENT (const_tree @var{type})
+This hook can be used to define the alignment for a vector of type
+@var{type}, in order to comply with a platform ABI.  The default is to
+require natural alignment for vector types.  The alignment returned by
+this hook must be a power-of-two multiple of the default alignment of
+the vector element type.
+@end deftypefn
+
 @defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})
 If defined, a C expression to compute the alignment for stack slot.
 @var{type} is the data type, @var{mode} is the widest mode available,
diff -Naur gcc-4.6.3.orig/gcc/doc/tm.texi.in gcc-4.6.3/gcc/doc/tm.texi.in
--- gcc-4.6.3.orig/gcc/doc/tm.texi.in	2011-06-04 10:15:48.000000000 +0000
+++ gcc-4.6.3/gcc/doc/tm.texi.in	2012-08-10 13:26:44.694722000 +0000
@@ -1108,6 +1108,8 @@
 If the value of this macro has a type, it should be an unsigned type.
 @end defmac
 
+@hook TARGET_VECTOR_ALIGNMENT
+
 @defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})
 If defined, a C expression to compute the alignment for stack slot.
 @var{type} is the data type, @var{mode} is the widest mode available,
diff -Naur gcc-4.6.3.orig/gcc/expr.c gcc-4.6.3/gcc/expr.c
--- gcc-4.6.3.orig/gcc/expr.c	2012-02-09 17:28:22.000000000 +0000
+++ gcc-4.6.3/gcc/expr.c	2012-06-28 12:01:16.874415000 +0000
@@ -5971,6 +5971,8 @@
 		|| bitpos % GET_MODE_ALIGNMENT (mode))
 	       && SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target)))
 	      || (bitpos % BITS_PER_UNIT != 0)))
+      || (bitsize >= 0 && mode != BLKmode
+	  && GET_MODE_BITSIZE (mode) > bitsize)
       /* If the RHS and field are a constant size and the size of the
 	 RHS isn't the same size as the bitfield, we must use bitfield
 	 operations.  */
@@ -9182,6 +9184,7 @@
 	orig_op0 = op0
 	  = expand_expr (tem,
 			 (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE
+			  && COMPLETE_TYPE_P (TREE_TYPE (tem))
 			  && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))
 			      != INTEGER_CST)
 			  && modifier != EXPAND_STACK_PARM
diff -Naur gcc-4.6.3.orig/gcc/fortran/decl.c gcc-4.6.3/gcc/fortran/decl.c
--- gcc-4.6.3.orig/gcc/fortran/decl.c	2011-06-02 19:53:02.000000000 +0000
+++ gcc-4.6.3/gcc/fortran/decl.c	2012-06-14 13:11:27.149798000 +0000
@@ -3623,8 +3623,9 @@
 	}
     }
 
-  /* Module variables implicitly have the SAVE attribute.  */
-  if (gfc_current_state () == COMP_MODULE && !current_attr.save)
+  /* Since Fortran 2008 module variables implicitly have the SAVE attribute.  */
+  if (gfc_current_state () == COMP_MODULE && !current_attr.save
+      && (gfc_option.allow_std & GFC_STD_F2008) != 0)
     current_attr.save = SAVE_IMPLICIT;
 
   colon_seen = 1;
diff -Naur gcc-4.6.3.orig/gcc/fortran/expr.c gcc-4.6.3/gcc/fortran/expr.c
--- gcc-4.6.3.orig/gcc/fortran/expr.c	2012-01-19 22:21:43.000000000 +0000
+++ gcc-4.6.3/gcc/fortran/expr.c	2012-05-02 12:53:20.873985000 +0000
@@ -4474,7 +4474,11 @@
       if (ptr_component && ref->type == REF_COMPONENT)
 	check_intentin = false;
       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
-	ptr_component = true;
+	{
+	  ptr_component = true;
+	  if (!pointer)
+	    check_intentin = false;
+	}
     }
   if (check_intentin && sym->attr.intent == INTENT_IN)
     {
diff -Naur gcc-4.6.3.orig/gcc/fortran/resolve.c gcc-4.6.3/gcc/fortran/resolve.c
--- gcc-4.6.3.orig/gcc/fortran/resolve.c	2012-01-25 08:11:56.000000000 +0000
+++ gcc-4.6.3/gcc/fortran/resolve.c	2012-06-05 13:05:31.580646000 +0000
@@ -1452,7 +1452,7 @@
 
   if (sym->intmod_sym_id)
     isym = gfc_intrinsic_function_by_id ((gfc_isym_id) sym->intmod_sym_id);
-  else
+  else if (!sym->attr.subroutine)
     isym = gfc_find_function (sym->name);
 
   if (isym)
@@ -9700,7 +9700,8 @@
       || sym->attr.data
       || sym->module
       || sym->attr.cray_pointee
-      || sym->attr.cray_pointer)
+      || sym->attr.cray_pointer
+      || sym->assoc)
     return NULL;
 
   /* Now we'll try to build an initializer expression.  */
diff -Naur gcc-4.6.3.orig/gcc/fortran/trans-array.c gcc-4.6.3/gcc/fortran/trans-array.c
--- gcc-4.6.3.orig/gcc/fortran/trans-array.c	2011-12-08 20:54:57.000000000 +0000
+++ gcc-4.6.3/gcc/fortran/trans-array.c	2012-07-14 15:24:12.262320000 +0000
@@ -2056,6 +2056,11 @@
   gfc_se se;
   int n;
 
+  /* Don't evaluate the arguments for realloc_lhs_loop_for_fcn_call; otherwise,
+     arguments could get evaluated multiple times.  */
+  if (ss->is_alloc_lhs)
+    return;
+
   /* TODO: This can generate bad code if there are ordering dependencies,
      e.g., a callee allocated function and an unknown size constructor.  */
   gcc_assert (ss != NULL);
@@ -7548,7 +7553,7 @@
   scalar = 1;
   for (; arg; arg = arg->next)
     {
-      if (!arg->expr)
+      if (!arg->expr || arg->expr->expr_type == EXPR_NULL)
 	continue;
 
       newss = gfc_walk_subexpr (head, arg->expr);
diff -Naur gcc-4.6.3.orig/gcc/fortran/trans-types.c gcc-4.6.3/gcc/fortran/trans-types.c
--- gcc-4.6.3.orig/gcc/fortran/trans-types.c	2011-11-25 17:18:05.000000000 +0000
+++ gcc-4.6.3/gcc/fortran/trans-types.c	2012-03-10 09:20:22.792570000 +0000
@@ -2519,7 +2519,11 @@
 	      || sym->attr.flavor == FL_PROGRAM);
 
   if (sym->backend_decl)
-    return TREE_TYPE (sym->backend_decl);
+    {
+      if (sym->attr.proc_pointer)
+	return TREE_TYPE (TREE_TYPE (sym->backend_decl));
+      return TREE_TYPE (sym->backend_decl);
+    }
 
   alternate_return = 0;
   typelist = NULL_TREE;
diff -Naur gcc-4.6.3.orig/gcc/fortran/trans.c gcc-4.6.3/gcc/fortran/trans.c
--- gcc-4.6.3.orig/gcc/fortran/trans.c	2011-02-23 22:38:27.000000000 +0000
+++ gcc-4.6.3/gcc/fortran/trans.c	2012-06-01 20:06:39.161162000 +0000
@@ -1005,15 +1005,12 @@
   if (!res && size != 0)
     _gfortran_os_error ("Allocation would exceed memory limit");
 
-  if (size == 0)
-    return NULL;
-
   return res;
 }  */
 tree
 gfc_call_realloc (stmtblock_t * block, tree mem, tree size)
 {
-  tree msg, res, nonzero, zero, null_result, tmp;
+  tree msg, res, nonzero, null_result, tmp;
   tree type = TREE_TYPE (mem);
 
   size = gfc_evaluate_now (size, block);
@@ -1044,15 +1041,6 @@
 			 build_empty_stmt (input_location));
   gfc_add_expr_to_block (block, tmp);
 
-  /* if (size == 0) then the result is NULL.  */
-  tmp = fold_build2_loc (input_location, MODIFY_EXPR, type, res,
-			 build_int_cst (type, 0));
-  zero = fold_build1_loc (input_location, TRUTH_NOT_EXPR, boolean_type_node,
-			  nonzero);
-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, zero, tmp,
-			 build_empty_stmt (input_location));
-  gfc_add_expr_to_block (block, tmp);
-
   return res;
 }
 
diff -Naur gcc-4.6.3.orig/gcc/gcov-iov.c gcc-4.6.3/gcc/gcov-iov.c
--- gcc-4.6.3.orig/gcc/gcov-iov.c	2011-01-03 20:52:22.000000000 +0000
+++ gcc-4.6.3/gcc/gcov-iov.c	2012-06-22 12:32:34.527642000 +0000
@@ -19,8 +19,8 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-#include <stdio.h>
-#include <stdlib.h>
+#include "bconfig.h"
+#include "system.h"
 
 /* Command line arguments are the base GCC version and the development
    phase (the latter may be an empty string).  */
@@ -48,8 +48,14 @@
   if (*ptr == '.')
     minor = strtoul (ptr + 1, 0, 10);
 
+  /* For releases the development phase is an empty string, for
+     prerelease versions on a release branch it is "prerelease".
+     Consider both equal as patch-level releases do not change
+     the GCOV version either.
+     On the trunk the development phase is "experimental".  */
   phase = argv[2][0];
-  if (phase == '\0')
+  if (phase == '\0'
+      || strcmp (argv[2], "prerelease") == 0)
     phase = '*';
 
   v[0] = (major < 10 ? '0' : 'A' - 10) + major;
diff -Naur gcc-4.6.3.orig/gcc/gimple.c gcc-4.6.3/gcc/gimple.c
--- gcc-4.6.3.orig/gcc/gimple.c	2011-08-03 18:56:02.000000000 +0000
+++ gcc-4.6.3/gcc/gimple.c	2012-05-22 09:23:01.937094000 +0000
@@ -2275,8 +2275,6 @@
 bool
 gimple_has_side_effects (const_gimple s)
 {
-  unsigned i;
-
   if (is_gimple_debug (s))
     return false;
 
@@ -2292,45 +2290,15 @@
 
   if (is_gimple_call (s))
     {
-      unsigned nargs = gimple_call_num_args (s);
+      int flags = gimple_call_flags (s);
 
-      if (!(gimple_call_flags (s) & (ECF_CONST | ECF_PURE)))
-        return true;
-      else if (gimple_call_flags (s) & ECF_LOOPING_CONST_OR_PURE)
-	/* An infinite loop is considered a side effect.  */
+      /* An infinite loop is considered a side effect.  */
+      if (!(flags & (ECF_CONST | ECF_PURE))
+	  || (flags & ECF_LOOPING_CONST_OR_PURE))
 	return true;
 
-      if (gimple_call_lhs (s)
-          && TREE_SIDE_EFFECTS (gimple_call_lhs (s)))
-	{
-	  gcc_checking_assert (gimple_has_volatile_ops (s));
-	  return true;
-	}
-
-      if (TREE_SIDE_EFFECTS (gimple_call_fn (s)))
-        return true;
-
-      for (i = 0; i < nargs; i++)
-        if (TREE_SIDE_EFFECTS (gimple_call_arg (s, i)))
-	  {
-	    gcc_checking_assert (gimple_has_volatile_ops (s));
-	    return true;
-	  }
-
       return false;
     }
-  else
-    {
-      for (i = 0; i < gimple_num_ops (s); i++)
-	{
-	  tree op = gimple_op (s, i);
-	  if (op && TREE_SIDE_EFFECTS (op))
-	    {
-	      gcc_checking_assert (gimple_has_volatile_ops (s));
-	      return true;
-	    }
-	}
-    }
 
   return false;
 }
diff -Naur gcc-4.6.3.orig/gcc/gthr-posix.h gcc-4.6.3/gcc/gthr-posix.h
--- gcc-4.6.3.orig/gcc/gthr-posix.h	2011-01-03 20:52:22.000000000 +0000
+++ gcc-4.6.3/gcc/gthr-posix.h	2012-06-05 21:42:30.036539000 +0000
@@ -239,16 +239,15 @@
 static inline int
 __gthread_active_p (void)
 {
-  static void *const __gthread_active_ptr
-    = __extension__ (void *) &__gthrw_(
 /* Android's C library does not provide pthread_cancel, check for
    `pthread_create' instead.  */
 #ifndef __BIONIC__
-				       pthread_cancel
+  static void *const __gthread_active_ptr
+    = __extension__ (void *) &__gthrw_(pthread_cancel);
 #else
-				       pthread_create
+  static void *const __gthread_active_ptr
+    = __extension__ (void *) &__gthrw_(pthread_create);
 #endif
-				       );
   return __gthread_active_ptr != 0;
 }
 
diff -Naur gcc-4.6.3.orig/gcc/ipa-prop.c gcc-4.6.3/gcc/ipa-prop.c
--- gcc-4.6.3.orig/gcc/ipa-prop.c	2011-12-13 22:03:05.000000000 +0000
+++ gcc-4.6.3/gcc/ipa-prop.c	2012-07-02 15:53:21.612759000 +0000
@@ -704,12 +704,11 @@
       || is_global_var (base))
     return;
 
-  if (detect_type_change (op, base, call, jfunc, offset))
-    return;
-
   binfo = TYPE_BINFO (TREE_TYPE (base));
-  if (!binfo)
+  if (!binfo
+      || detect_type_change (op, base, call, jfunc, offset))
     return;
+
   binfo = get_binfo_at_offset (binfo, offset, TREE_TYPE (op));
   if (binfo)
     {
diff -Naur gcc-4.6.3.orig/gcc/lto/lto.c gcc-4.6.3/gcc/lto/lto.c
--- gcc-4.6.3.orig/gcc/lto/lto.c	2011-12-13 22:03:05.000000000 +0000
+++ gcc-4.6.3/gcc/lto/lto.c	2012-04-23 12:44:46.674224000 +0000
@@ -893,7 +893,8 @@
 
   for (node = cgraph_nodes; node; node = node->next)
     {
-      if (!partition_cgraph_node_p (node))
+      if (!partition_cgraph_node_p (node)
+	  || node->aux)
 	continue;
 
       file_data = node->local.lto_file_data;
@@ -923,13 +924,13 @@
 	  npartitions++;
 	}
 
-      if (!node->aux)
-        add_cgraph_node_to_partition (partition, node);
+      add_cgraph_node_to_partition (partition, node);
     }
 
   for (vnode = varpool_nodes; vnode; vnode = vnode->next)
     {
-      if (!partition_varpool_node_p (vnode))
+      if (!partition_varpool_node_p (vnode)
+	  || vnode->aux)
 	continue;
       file_data = vnode->lto_file_data;
       slot = pointer_map_contains (pmap, file_data);
@@ -943,8 +944,7 @@
 	  npartitions++;
 	}
 
-      if (!vnode->aux)
-        add_varpool_node_to_partition (partition, vnode);
+      add_varpool_node_to_partition (partition, vnode);
     }
   for (node = cgraph_nodes; node; node = node->next)
     node->aux = NULL;
@@ -1050,8 +1050,9 @@
 
   for (i = 0; i < n_nodes; i++)
     {
-      if (!order[i]->aux)
-        add_cgraph_node_to_partition (partition, order[i]);
+      if (order[i]->aux)
+	continue;
+      add_cgraph_node_to_partition (partition, order[i]);
       total_size -= order[i]->global.size;
 
       /* Once we added a new node to the partition, we also want to add
@@ -1231,6 +1232,8 @@
 	    }
 	  i = best_i;
  	  /* When we are finished, avoid creating empty partition.  */
+	  while (i < n_nodes - 1 && order[i + 1]->aux)
+	    i++;
 	  if (i == n_nodes - 1)
 	    break;
 	  partition = new_partition ("");
diff -Naur gcc-4.6.3.orig/gcc/predict.c gcc-4.6.3/gcc/predict.c
--- gcc-4.6.3.orig/gcc/predict.c	2011-01-22 21:47:40.000000000 +0000
+++ gcc-4.6.3/gcc/predict.c	2012-03-25 10:59:19.696090000 +0000
@@ -1790,7 +1790,8 @@
 static void
 predict_paths_for_bb (basic_block cur, basic_block bb,
 		      enum br_predictor pred,
-		      enum prediction taken)
+		      enum prediction taken,
+		      bitmap visited)
 {
   edge e;
   edge_iterator ei;
@@ -1811,7 +1812,7 @@
 	continue;
       gcc_assert (bb == cur || dominated_by_p (CDI_POST_DOMINATORS, cur, bb));
 
-      /* See if there is how many edge from e->src that is not abnormal
+      /* See if there is an edge from e->src that is not abnormal
 	 and does not lead to BB.  */
       FOR_EACH_EDGE (e2, ei2, e->src->succs)
 	if (e2 != e
@@ -1824,16 +1825,20 @@
 
       /* If there is non-abnormal path leaving e->src, predict edge
 	 using predictor.  Otherwise we need to look for paths
-	 leading to e->src.  */
+	 leading to e->src.
+
+	 The second may lead to infinite loop in the case we are predicitng
+	 regions that are only reachable by abnormal edges.  We simply
+	 prevent visiting given BB twice.  */
       if (found)
         predict_edge_def (e, pred, taken);
-      else
-	predict_paths_for_bb (e->src, e->src, pred, taken);
+      else if (bitmap_set_bit (visited, e->src->index))
+	predict_paths_for_bb (e->src, e->src, pred, taken, visited);
     }
   for (son = first_dom_son (CDI_POST_DOMINATORS, cur);
        son;
        son = next_dom_son (CDI_POST_DOMINATORS, son))
-    predict_paths_for_bb (son, bb, pred, taken);
+    predict_paths_for_bb (son, bb, pred, taken, visited);
 }
 
 /* Sets branch probabilities according to PREDiction and
@@ -1843,7 +1848,9 @@
 predict_paths_leading_to (basic_block bb, enum br_predictor pred,
 			  enum prediction taken)
 {
-  predict_paths_for_bb (bb, bb, pred, taken);
+  bitmap visited = BITMAP_ALLOC (NULL);
+  predict_paths_for_bb (bb, bb, pred, taken, visited);
+  BITMAP_FREE (visited);
 }
 
 /* Like predict_paths_leading_to but take edge instead of basic block.  */
@@ -1866,7 +1873,11 @@
 	break;
       }
   if (!has_nonloop_edge)
-    predict_paths_for_bb (bb, bb, pred, taken);
+    {
+      bitmap visited = BITMAP_ALLOC (NULL);
+      predict_paths_for_bb (bb, bb, pred, taken, visited);
+      BITMAP_FREE (visited);
+    }
   else
     predict_edge_def (e, pred, taken);
 }
diff -Naur gcc-4.6.3.orig/gcc/stor-layout.c gcc-4.6.3/gcc/stor-layout.c
--- gcc-4.6.3.orig/gcc/stor-layout.c	2012-02-20 22:09:48.000000000 +0000
+++ gcc-4.6.3/gcc/stor-layout.c	2012-08-10 13:26:44.694722000 +0000
@@ -660,12 +660,13 @@
 	  /* See if we can use an ordinary integer mode for a bit-field.
 	     Conditions are: a fixed size that is correct for another mode,
 	     occupying a complete byte or bytes on proper boundary,
-	     and not volatile or not -fstrict-volatile-bitfields.  */
+	     and not -fstrict-volatile-bitfields.  If the latter is set,
+	     we unfortunately can't check TREE_THIS_VOLATILE, as a cast
+	     may make a volatile object later.  */
 	  if (TYPE_SIZE (type) != 0
 	      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
 	      && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT
-	      && !(TREE_THIS_VOLATILE (decl)
-		   && flag_strict_volatile_bitfields > 0))
+	      && flag_strict_volatile_bitfields <= 0)
 	    {
 	      enum machine_mode xmode
 		= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);
@@ -1926,9 +1927,17 @@
 	TYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),
 					    bitsize_int (nunits), 0);
 
-	/* Always naturally align vectors.  This prevents ABI changes
-	   depending on whether or not native vector modes are supported.  */
-	TYPE_ALIGN (type) = tree_low_cst (TYPE_SIZE (type), 0);
+	/* For vector types, we do not default to the mode's alignment.
+	   Instead, query a target hook, defaulting to natural alignment.
+	   This prevents ABI changes depending on whether or not native
+	   vector modes are supported.  */
+	TYPE_ALIGN (type) = targetm.vector_alignment (type);
+
+	/* However, if the underlying mode requires a bigger alignment than
+	   what the target hook provides, we cannot use the mode.  For now,
+	   simply reject that case.  */
+	gcc_assert (TYPE_ALIGN (type)
+		    >= GET_MODE_ALIGNMENT (TYPE_MODE (type)));
         break;
       }
 
diff -Naur gcc-4.6.3.orig/gcc/target.def gcc-4.6.3/gcc/target.def
--- gcc-4.6.3.orig/gcc/target.def	2011-06-04 10:15:48.000000000 +0000
+++ gcc-4.6.3/gcc/target.def	2012-08-10 13:26:44.694722000 +0000
@@ -1611,6 +1611,16 @@
  bool, (enum machine_mode mode),
  hook_bool_mode_false)
 
+DEFHOOK
+(vector_alignment,
+ "This hook can be used to define the alignment for a vector of type\n\
+@var{type}, in order to comply with a platform ABI.  The default is to\n\
+require natural alignment for vector types.  The alignment returned by\n\
+this hook must be a power-of-two multiple of the default alignment of\n\
+the vector element type.",
+ HOST_WIDE_INT, (const_tree type),
+ default_vector_alignment)
+
 /* Compute cost of moving data from a register of class FROM to one of
    TO, using MODE.  */
 DEFHOOK
diff -Naur gcc-4.6.3.orig/gcc/target.h gcc-4.6.3/gcc/target.h
--- gcc-4.6.3.orig/gcc/target.h	2011-01-14 15:02:20.000000000 +0000
+++ gcc-4.6.3/gcc/target.h	2012-03-02 14:51:58.551861000 +0000
@@ -128,7 +128,8 @@
   scalar_to_vec,
   cond_branch_not_taken,
   cond_branch_taken,
-  vec_perm
+  vec_perm,
+  vec_promote_demote
 };
 
 /* Sets of optimization levels at which an option may be enabled by
diff -Naur gcc-4.6.3.orig/gcc/targhooks.c gcc-4.6.3/gcc/targhooks.c
--- gcc-4.6.3.orig/gcc/targhooks.c	2011-01-14 15:02:20.000000000 +0000
+++ gcc-4.6.3/gcc/targhooks.c	2012-08-10 13:26:44.694722000 +0000
@@ -529,6 +529,7 @@
       case scalar_to_vec:
       case cond_branch_not_taken:
       case vec_perm:
+      case vec_promote_demote:
         return 1;
 
       case unaligned_load:
@@ -978,6 +979,13 @@
    return id;
 }
 
+/* Default to natural alignment for vector types.  */
+HOST_WIDE_INT
+default_vector_alignment (const_tree type)
+{
+  return tree_low_cst (TYPE_SIZE (type), 0);
+}
+
 bool
 default_builtin_vector_alignment_reachable (const_tree type, bool is_packed)
 {
diff -Naur gcc-4.6.3.orig/gcc/targhooks.h gcc-4.6.3/gcc/targhooks.h
--- gcc-4.6.3.orig/gcc/targhooks.h	2011-01-14 15:02:20.000000000 +0000
+++ gcc-4.6.3/gcc/targhooks.h	2012-08-10 13:26:44.694722000 +0000
@@ -85,6 +85,8 @@
 
 extern tree default_builtin_reciprocal (unsigned int, bool, bool);
 
+extern HOST_WIDE_INT default_vector_alignment (const_tree);
+
 extern bool default_builtin_vector_alignment_reachable (const_tree, bool);
 extern bool
 default_builtin_support_vector_misalignment (enum machine_mode mode,
diff -Naur gcc-4.6.3.orig/gcc/testsuite/c-c++-common/abi-bf.c gcc-4.6.3/gcc/testsuite/c-c++-common/abi-bf.c
--- gcc-4.6.3.orig/gcc/testsuite/c-c++-common/abi-bf.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/c-c++-common/abi-bf.c	2012-03-29 02:15:29.973365000 +0000
@@ -0,0 +1,3 @@
+/* { dg-warning "incompatible" } */
+/* { dg-do compile } */
+/* { dg-options "-fstrict-volatile-bitfields -fabi-version=1" } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/g++.dg/cpp0x/nullptr28.C gcc-4.6.3/gcc/testsuite/g++.dg/cpp0x/nullptr28.C
--- gcc-4.6.3.orig/gcc/testsuite/g++.dg/cpp0x/nullptr28.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/g++.dg/cpp0x/nullptr28.C	2012-07-03 23:29:03.323158000 +0000
@@ -0,0 +1,17 @@
+// { dg-do run }
+// { dg-options "-std=c++0x -pedantic-errors" }
+
+typedef decltype(nullptr) nullptr_t;
+
+int i;
+nullptr_t n;
+const nullptr_t& f() { ++i; return n; }
+
+nullptr_t g() { return f(); }
+
+int main()
+{
+  g();
+  if (i != 1)
+    __builtin_abort ();
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/g++.dg/cpp0x/variadic-value1.C gcc-4.6.3/gcc/testsuite/g++.dg/cpp0x/variadic-value1.C
--- gcc-4.6.3.orig/gcc/testsuite/g++.dg/cpp0x/variadic-value1.C	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/g++.dg/cpp0x/variadic-value1.C	2012-05-23 21:29:55.463235000 +0000
@@ -0,0 +1,24 @@
+// PR c++/52796
+// { dg-options "-std=c++0x -pedantic-errors" }
+
+inline void *operator new(__SIZE_TYPE__ s, void *p) { return p; }
+
+struct A
+{
+  int i;
+  template<class... Ts>
+  A(Ts&&... ts): i(ts...) { }
+};
+
+static union {
+  unsigned char c[sizeof(A)];
+  int i;
+};
+
+int main()
+{
+  i = 0xdeadbeef;
+  new(c) A;
+  if (i != 0)
+    __builtin_abort();
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c gcc-4.6.3/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c	2012-03-24 13:47:46.199387000 +0000
@@ -0,0 +1,56 @@
+/* Inspired by the test case for PR middle-end/52640.  */
+
+typedef struct
+{
+    char *value;
+} REFERENCE;
+
+/* Add a few "extern int Xxxxxx ();" declarations.  */
+#undef DEF
+#undef LIM1
+#undef LIM2
+#undef LIM3
+#undef LIM4
+#undef LIM5
+#undef LIM6
+#define DEF(x) 	extern int x ()
+#define LIM1(x) DEF(x##0); DEF(x##1); DEF(x##2); DEF(x##3); DEF(x##4); \
+		DEF(x##5); DEF(x##6); DEF(x##7); DEF(x##8); DEF(x##9);
+#define LIM2(x) LIM1(x##0) LIM1(x##1) LIM1(x##2) LIM1(x##3) LIM1(x##4) \
+		LIM1(x##5) LIM1(x##6) LIM1(x##7) LIM1(x##8) LIM1(x##9)
+#define LIM3(x) LIM2(x##0) LIM2(x##1) LIM2(x##2) LIM2(x##3) LIM2(x##4) \
+		LIM2(x##5) LIM2(x##6) LIM2(x##7) LIM2(x##8) LIM2(x##9)
+#define LIM4(x) LIM3(x##0) LIM3(x##1) LIM3(x##2) LIM3(x##3) LIM3(x##4) \
+		LIM3(x##5) LIM3(x##6) LIM3(x##7) LIM3(x##8) LIM3(x##9)
+#define LIM5(x) LIM4(x##0) LIM4(x##1) LIM4(x##2) LIM4(x##3) LIM4(x##4) \
+		LIM4(x##5) LIM4(x##6) LIM4(x##7) LIM4(x##8) LIM4(x##9)
+#define LIM6(x) LIM5(x##0) LIM5(x##1) LIM5(x##2) LIM5(x##3) LIM5(x##4) \
+		LIM5(x##5) LIM5(x##6) LIM5(x##7) LIM5(x##8) LIM5(x##9)
+LIM5 (X);
+
+/* Add references to them, or GCC will simply ignore the extern decls.  */
+#undef DEF
+#undef LIM1
+#undef LIM2
+#undef LIM3
+#undef LIM4
+#undef LIM5
+#undef LIM6
+#define DEF(x)	(char *) x
+#define LIM1(x) DEF(x##0), DEF(x##1), DEF(x##2), DEF(x##3), DEF(x##4), \
+		DEF(x##5), DEF(x##6), DEF(x##7), DEF(x##8), DEF(x##9),
+#define LIM2(x) LIM1(x##0) LIM1(x##1) LIM1(x##2) LIM1(x##3) LIM1(x##4) \
+		LIM1(x##5) LIM1(x##6) LIM1(x##7) LIM1(x##8) LIM1(x##9)
+#define LIM3(x) LIM2(x##0) LIM2(x##1) LIM2(x##2) LIM2(x##3) LIM2(x##4) \
+		LIM2(x##5) LIM2(x##6) LIM2(x##7) LIM2(x##8) LIM2(x##9)
+#define LIM4(x) LIM3(x##0) LIM3(x##1) LIM3(x##2) LIM3(x##3) LIM3(x##4) \
+		LIM3(x##5) LIM3(x##6) LIM3(x##7) LIM3(x##8) LIM3(x##9)
+#define LIM5(x) LIM4(x##0) LIM4(x##1) LIM4(x##2) LIM4(x##3) LIM4(x##4) \
+		LIM4(x##5) LIM4(x##6) LIM4(x##7) LIM4(x##8) LIM4(x##9)
+#define LIM6(x) LIM5(x##0) LIM5(x##1) LIM5(x##2) LIM5(x##3) LIM5(x##4) \
+		LIM5(x##5) LIM5(x##6) LIM5(x##7) LIM5(x##8) LIM5(x##9)
+REFERENCE references[] = {
+  LIM5 (X)
+  0
+};
+
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/compile/pr53418-1.c gcc-4.6.3/gcc/testsuite/gcc.c-torture/compile/pr53418-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/compile/pr53418-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.c-torture/compile/pr53418-1.c	2012-05-21 20:12:05.729358000 +0000
@@ -0,0 +1,5 @@
+void
+f (void)
+{
+  int i = (0 ? 1 : 0U / 0);
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/compile/pr53418-2.c gcc-4.6.3/gcc/testsuite/gcc.c-torture/compile/pr53418-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/compile/pr53418-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.c-torture/compile/pr53418-2.c	2012-05-21 20:12:05.729358000 +0000
@@ -0,0 +1,5 @@
+void
+f (void)
+{
+  int i = (1 ? 0U / 0 : 1);
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/execute/20120427-1.c gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/20120427-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/execute/20120427-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/20120427-1.c	2012-04-30 09:56:27.764158000 +0000
@@ -0,0 +1,36 @@
+typedef struct sreal
+{
+  unsigned sig;		/* Significant.  */
+  int exp;		/* Exponent.  */
+} sreal;
+
+sreal_compare (sreal *a, sreal *b)
+{
+  if (a->exp > b->exp)
+    return 1;
+  if (a->exp < b->exp)
+    return -1;
+  if (a->sig > b->sig)
+    return 1;
+  return -(a->sig < b->sig);
+}
+
+sreal a[] = {
+   { 0, 0 },
+   { 1, 0 },
+   { 0, 1 },
+   { 1, 1 }
+};
+
+int main()
+{
+  int i, j;
+  for (i = 0; i <= 3; i++) {
+    for (j = 0; j < 3; j++) {
+      if (i < j && sreal_compare(&a[i], &a[j]) != -1) abort();
+      if (i == j && sreal_compare(&a[i], &a[j]) != 0) abort();
+      if (i > j && sreal_compare(&a[i], &a[j]) != 1) abort();
+    }
+  }
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/execute/pr53084.c gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/pr53084.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.c-torture/execute/pr53084.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/pr53084.c	2012-04-24 06:14:37.854759000 +0000
@@ -0,0 +1,18 @@
+/* PR middle-end/53084 */
+
+extern void abort (void);
+
+__attribute__((noinline, noclone)) void
+bar (const char *p)
+{
+  if (p[0] != 'o' || p[1] != 'o' || p[2])
+    abort ();
+}
+
+int
+main ()
+{
+  static const char *const foo[] = {"foo" + 1};
+  bar (foo[0]);
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/20020201-1.c gcc-4.6.3/gcc/testsuite/gcc.dg/20020201-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/20020201-1.c	2005-03-31 18:14:11.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/20020201-1.c	2012-08-06 07:11:07.208019000 +0000
@@ -7,11 +7,7 @@
 /* { dg-options "-fprofile-arcs" } */
 /* { dg-do run { target native } } */
 
-extern void abort (void);
-extern void exit (int);
-
-int rand (void);
-void srand (unsigned int seed);
+#include <stdlib.h>
 
 int globvar;
 
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/align-2.c gcc-4.6.3/gcc/testsuite/gcc.dg/align-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/align-2.c	2004-10-19 19:21:41.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/align-2.c	2012-08-10 13:26:44.694722000 +0000
@@ -1,5 +1,5 @@
 /* PR 17962 */
-/* { dg-do compile } */
+/* { dg-do compile { target vect_natural_alignment } } */
 /* { dg-options "" } */
 
 typedef float v4 __attribute__((vector_size(sizeof(float)*4)));
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/pr52862.c gcc-4.6.3/gcc/testsuite/gcc.dg/pr52862.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/pr52862.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/pr52862.c	2012-05-22 09:17:42.260176000 +0000
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+void ASMAtomicWritePtrVoid(const void *pv);
+void rtThreadDestroy(void)
+{
+  void * const pvTypeChecked = ((void *)0);
+  ASMAtomicWritePtrVoid((void *)(pvTypeChecked));
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/stack-usage-1.c gcc-4.6.3/gcc/testsuite/gcc.dg/stack-usage-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/stack-usage-1.c	2011-01-05 13:25:36.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/stack-usage-1.c	2012-06-20 07:54:17.441164000 +0000
@@ -41,6 +41,8 @@
 #  define SIZE 160 /* 256 -  96 bytes for register save area */
 #elif defined (__SPU__)
 #  define SIZE 224
+#elif defined (__sh__)
+#  define SIZE 252
 #else
 #  define SIZE 256
 #endif
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr51071-2.c gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr51071-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr51071-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr51071-2.c	2012-05-22 09:23:01.937094000 +0000
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-fno-delete-null-pointer-checks" } */
+
+extern struct module __this_module;
+static inline void
+trace_module_get  (struct module *mod, unsigned long ip) { }
+struct module;
+static inline __attribute__((no_instrument_function))
+int try_module_get(struct module *module)
+{
+  int ret = 1;
+  if (module)
+    {
+      if (module_is_live(module))
+	{
+	  __label__ __here;
+	  asm("");
+	  __here:
+	  trace_module_get(module, (unsigned long)&&__here);
+	}
+      else
+	ret = 0;
+    }
+  return ret;
+}
+struct net_device;
+struct net_device_ops {
+    int (*ndo_open)(struct net_device *dev);
+};
+int t3e3_open(struct net_device *dev)
+{
+  int ret = hdlc_open(dev);
+  if (ret)
+    return ret;
+  try_module_get((&__this_module));
+  return 0;
+}
+const struct net_device_ops t3e3_ops = { .ndo_open = t3e3_open };
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr51071.c gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr51071.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr51071.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr51071.c	2012-05-22 09:23:01.937094000 +0000
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+
+void foo (void);
+void bar (void *);
+extern int t;
+
+static void kmalloc_large (int size, int flags)
+{
+  (void) size;
+  (void) flags;
+  foo ();
+  bar (({__here:&&__here;}));
+}
+
+static void kmalloc (int size, int flags)
+{
+  if (size)
+    {
+      if ((unsigned long) size > 0x1000)
+	kmalloc_large (size, flags);
+
+      if (flags)
+	bar (({__here:&&__here;}));
+    }
+}
+
+void compress_file_range (int i, int j, int k)
+{
+  int nr_pages = ({j < k;});
+
+  if (i || t)
+    kmalloc (0x1000UL * nr_pages, 0x40UL);
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr52407.c gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr52407.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr52407.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr52407.c	2012-05-22 09:20:15.992160000 +0000
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+typedef long long T;
+typedef T vl_t __attribute__((vector_size(2 * sizeof (T))));
+
+vl_t	ul[4], vl[4] = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
+
+static void
+mul_vl_l(vl_t *u, vl_t *v, T x, int m)
+{
+  vl_t	 w;
+  T *p = (T *)&w;
+  p[0] = p[1] = x;
+  while (m--)
+    *u++ = *v++ * w;
+}
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+  T *pl;
+
+  pl = (T *) &ul;
+  mul_vl_l(ul, vl, 2, 4);
+  for (i = 0; i < 8; i++)
+    if (pl[i] != 2 * (i + 1))
+      abort ();
+
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr52693.c gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr52693.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr52693.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr52693.c	2012-03-28 18:03:28.014541000 +0000
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+struct pair
+{
+  int x;
+  int y;
+};
+
+struct array
+{
+  struct pair elems[ 2 ];
+  unsigned index;
+};
+
+extern void abort ();
+
+void __attribute__ ((noinline,noclone))
+test_results (int x1, int y1, int x2, int y2)
+{
+  if (x1 != x2 || y1 != y2)
+    abort ();
+}
+
+int
+main (void)
+{
+  struct array arr = {{{1,2}, {3,4}}, 1};
+  struct pair last = arr.elems[arr.index];
+
+  test_results ( last.x, last.y, arr.elems[1].x, arr.elems[1].y);
+
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr53790.c gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr53790.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr53790.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr53790.c	2012-06-28 12:01:16.874415000 +0000
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+
+typedef struct s {
+    int value;
+} s_t;
+
+static inline int 
+read(s_t const *var)
+{
+  return var->value;
+}
+
+int main()
+{
+  extern union u extern_var;
+  return read((s_t *)&extern_var);
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr53908.c gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr53908.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/torture/pr53908.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/torture/pr53908.c	2012-07-16 09:36:04.162835000 +0000
@@ -0,0 +1,288 @@
+/* { dg-do run } */
+/* SEGV at comment below.  */
+typedef unsigned int size_t;
+typedef enum har {
+  he_fatal = (-199),
+  he_not_initialized,
+  he_bad_input,
+  he_memory_too_small,
+  he_bad_action,
+  he_duplicate,
+  he_bad_nonce,
+  he_stale_nonce,
+  he_bad_credentials,
+  he_bad_user,
+  he_no_such_user,
+  he_bad_passwd,
+  he_unknown_auth_scheme,
+  he_not_found,
+  he_failed_digest_file_check,
+  he_failed_digest_file_save,
+  he_process_not_privileged,
+  he_other,
+  he_end_of_range,
+  ha_no_error = 0,
+  ha_no_value = 1
+} har;
+typedef enum realm_type
+{
+  axis_realm = 0,
+  ws_realm
+} realm_type;
+
+__attribute__((__noclone__, __noinline__))
+har has_www_auth(char *, size_t, realm_type, har);
+
+__attribute__((__noclone__, __noinline__))
+har has_auth_user(const char *, const char *, realm_type, char *, size_t);
+
+__attribute__((__noclone__, __noinline__))
+char *ha_get_string_value(void);
+
+typedef struct
+{
+  unsigned int track_id;
+  char* user;
+  char* realm;
+  char* authent;
+  int internal_realm;
+} request;
+enum user_response {
+  file_not_found_user_response = -3,
+  access_denied_user_response = -2,
+  no_user_response = -1,
+  ok_user_response = 0
+};
+struct realm_group {
+  char *name;
+  int id;
+  struct realm_group *next;
+};
+struct realm {
+  char *name;
+  char *space;
+  struct realm_group *groups;
+  struct realm *next;
+};
+struct user_info {
+  char *name;
+  int no_groups;
+  int groups[128];
+  struct user_info *next;
+};
+static struct user_info *find_user(const char *user_name);
+static int is_member_of_groups(const struct user_info *user_item,
+                                const struct realm_group *groups);
+int authent_author(request *req);
+struct realm *realms = ((void *)0);
+struct user_info *users = ((void *)0);
+static struct user_info*
+find_user(const char *user_name)
+{
+  struct user_info *user_item;
+  user_item = users;
+  while (user_item != ((void *)0)) {
+    /* SEGV due to NULL access here on user_name.  See also comment below.  */
+    if ((__builtin_strcmp(user_item->name, user_name) == 0))
+      break;
+    user_item = user_item->next;
+  }
+  return user_item;
+}
+static int
+is_member_of_groups(const struct user_info *user_item,
+                    const struct realm_group *groups)
+{
+  const struct realm_group *group_item;
+  int i;
+  group_item = groups;
+  while (group_item != ((void *)0)) {
+    for (i = 0; i < user_item->no_groups; i++)
+      if (user_item->groups[i] == group_item->id)
+	return 0;
+    group_item = group_item->next;
+  }
+  return -1;
+}
+char *foo (void) __attribute__((__noclone__, __noinline__));
+char* g_strdup (const char *str) __attribute__((__malloc__, __noclone__, __noinline__));
+int g_strcmp0 (const char *str1, const char *str2);
+static int
+is_basic(char **user)
+{
+  char *passwd_ptr;
+  char *authent = foo();
+  passwd_ptr = __builtin_strchr(authent, ':');
+  if (passwd_ptr != ((void *)0)) {
+    *user = g_strdup(authent);
+    return 0;
+  }
+  return -1;
+}
+static int
+is_digest(char **user)
+{
+  int ret_val = -1;
+  char *authent;
+  authent = ha_get_string_value();
+  if (authent) {
+    *user = g_strdup(authent);
+    ret_val = 0;
+  }
+  return ret_val;
+}
+__attribute__((__noclone__, __noinline__))
+void g_free (void * mem);
+static enum user_response
+get_user_info_from_header(const realm_type type,
+                          char **user_name,
+                          struct user_info **user_item)
+{
+  int ret_val = no_user_response;
+  if ((type == ws_realm)) {
+    if (is_basic(user_name) == 0)
+      ret_val = access_denied_user_response;
+    if (is_digest(user_name) == 0)
+      ret_val = ok_user_response;
+  } else {
+    if (is_basic(user_name) < 0 &&
+	/* Load of *user_name here, but not after the is_digest call.  */
+	is_digest(user_name) < 0)
+      ;
+    else if ((*user_item = find_user(*user_name)) != ((void *)0))
+      ret_val = ok_user_response;
+    else
+      ret_val = access_denied_user_response;
+    if (ret_val != ok_user_response)
+      g_free(*user_name);
+  }
+  return ret_val;
+}
+static enum user_response
+authenticate_user(request *req,
+                  char **user_name,
+                  struct user_info **user_item)
+{
+  char *authent = ((void *)0);
+  har resp = ha_no_value;
+  enum user_response user_resp;
+  int ret_val = no_user_response;
+  if (req->authent && __builtin_strlen(req->authent)) {
+    authent = req->authent;
+    user_resp = get_user_info_from_header(req->internal_realm,
+                                          user_name,
+                                          user_item);
+    if (user_resp == ok_user_response) {
+      resp = has_auth_user(authent, 0, req->internal_realm, "", 1);
+      if (resp == ha_no_error)
+	ret_val = ok_user_response;
+      else if (resp != he_stale_nonce)
+	ret_val = access_denied_user_response;
+    } else if (user_resp == access_denied_user_response)
+      ret_val = access_denied_user_response;
+  }
+  if (resp != he_memory_too_small && resp != ha_no_error)
+    resp = has_www_auth("", 1, req->internal_realm, resp);
+  return ret_val;
+}
+
+int __attribute__ ((__noinline__, __noclone__))
+authent_author(request *req)
+{
+  struct realm *realm;
+  char *user_name = ((void *)0);
+  struct user_info *user_item = ((void *)0);
+  int res = 0;
+  asm ("");
+  realm = realms;
+  if (__builtin_strcmp("Wsd", realm->name) == 0) {
+    req->internal_realm = ws_realm;
+    is_digest(&user_name);
+  }
+  if (authenticate_user(req, &user_name, &user_item) < 0) {
+    if (user_name != ((void *)0))
+      req->user = user_name;
+    res = -2;
+    goto authent_author_return;
+  }
+  if (is_member_of_groups(user_item, realm->groups) < 0)
+    res = -1;
+authent_author_return:
+  return res;
+}
+
+int good0, good1, good2;
+
+__attribute__ ((__noinline__, __noclone__))
+char *foo(void)
+{
+  asm ("");
+  good0++;
+  return "";
+}
+
+__attribute__ ((__noinline__, __noclone__))
+char *ha_get_string_value(void)
+{
+  asm ("");
+  good1++;
+  return "f";
+}
+
+__attribute__ ((__noinline__, __noclone__))
+har has_auth_user(const char *a, const char *b, realm_type c, char *d, size_t e)
+{
+  asm ("");
+  if (*a != 'z' || a[1] != 0 || b != 0 || c != axis_realm || *d != 0
+      || e != 1)
+    __builtin_abort ();
+  return ha_no_error;
+}
+
+__attribute__ ((__noinline__, __noclone__))
+har has_www_auth(char *a, size_t b, realm_type c, har d)
+{
+  (void)(*a+b+c+d);
+  asm ("");
+  __builtin_abort ();
+}
+
+
+char *strdupped_user = "me";
+__attribute__((__malloc__, __noclone__, __noinline__))
+char* g_strdup (const char *str)
+{
+  asm ("");
+  if (*str != 'f')
+    __builtin_abort ();
+  good2++;
+  return strdupped_user;
+}
+
+__attribute__((__noclone__, __noinline__))
+void g_free (void * mem)
+{
+  (void)mem;
+  asm ("");
+  __builtin_abort ();
+}
+
+struct user_info me = { .name = "me", .no_groups = 1, .groups = {42}, .next = 0};
+struct user_info you = { .name = "you", .next = &me};
+struct realm_group xgroups = { .name = "*", .id = 42, .next = 0};
+
+int main(void)
+{
+  char *orig_user = "?";
+  struct realm r = { .name = "x", .space = "space?", .groups = &xgroups, .next = 0};
+  request req = { .user = orig_user, .realm = "!", .authent = "z",
+		  .internal_realm = axis_realm};
+  realms = &r;
+  users = &you;
+  if (authent_author (&req) != 0 || good0 != 1 || good1 != 1 || good2 != 1
+      || req.user != orig_user
+      || req.internal_realm != axis_realm)
+    __builtin_abort ();
+  __builtin_exit (0);
+}
+
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/slp-25.c gcc-4.6.3/gcc/testsuite/gcc.dg/vect/slp-25.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/slp-25.c	2010-10-04 14:59:30.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/vect/slp-25.c	2012-08-10 13:26:44.694722000 +0000
@@ -57,5 +57,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || { ! vect_natural_alignment } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-1.c gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-1.c	2011-01-10 12:41:40.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-1.c	2012-08-10 13:26:44.694722000 +0000
@@ -49,6 +49,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-2.c gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-2.c	2011-01-10 12:41:40.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-2.c	2012-08-10 13:26:44.694722000 +0000
@@ -50,6 +50,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target vect_element_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-3.c gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-3.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-3.c	2010-11-22 13:59:45.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-3.c	2012-08-10 13:26:44.694722000 +0000
@@ -4,9 +4,7 @@
 #include "tree-vect.h"
 
 #define N 128
-#define RES 21888 
-
-/* unaligned store.  */
+#define RES 21640 
 
 int ib[N+10];
 int ia[N+10];
@@ -18,11 +16,11 @@
   int i, suma = 0, sumb = 0, sumc = 0;
 
   /* ib and ic have same misalignment, we peel to align them.  */
-  for (i = 1; i <= N; i++)
+  for (i = 0; i <= N; i++)
     {
       suma += ia[i];
-      sumb += ib[i+6];
-      sumc += ic[i+2];
+      sumb += ib[i+5];
+      sumc += ic[i+1];
     }
 
   /* check results:  */
@@ -49,7 +47,7 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-4.c gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-4.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/vect/vect-peel-4.c	2011-01-10 12:41:40.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/vect/vect-peel-4.c	2012-08-10 13:26:44.694722000 +0000
@@ -16,13 +16,13 @@
   /* Don't peel keeping one load and the store aligned.  */
   for (i = 0; i <= N; i++)
     {
-      ia[i] = ib[i] + ib[i+6];
+      ia[i] = ib[i] + ib[i+5];
     }
 
   /* check results:  */
   for (i = 1; i <= N; i++)
     {
-      if (ia[i] != ib[i] + ib[i+6])
+      if (ia[i] != ib[i] + ib[i+5])
         abort ();
     }
 
@@ -44,7 +44,7 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.dg/volatile-bitfields-2.c gcc-4.6.3/gcc/testsuite/gcc.dg/volatile-bitfields-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.dg/volatile-bitfields-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.dg/volatile-bitfields-2.c	2012-03-29 02:15:29.973365000 +0000
@@ -0,0 +1,15 @@
+/* { dg-do run } */
+/* { dg-options "-fstrict-volatile-bitfields" } */
+
+extern void abort(void);
+struct thing {
+  volatile unsigned short a: 8;
+  volatile unsigned short b: 8;
+} t = {1,2};
+
+int main()
+{
+  t.a = 3;
+  if (t.a !=3 || t.b !=2) abort();
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c gcc-4.6.3/gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/arm/volatile-bitfields-4.c	2012-03-29 02:15:29.973365000 +0000
@@ -0,0 +1,30 @@
+/* { dg-require-effective-target arm_eabi } */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-times "ldr\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]" 2 } } */
+/* { dg-final { scan-assembler-times "str\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]" 2 } } */
+/* { dg-final { scan-assembler-not "strb" } } */
+
+struct thing {
+  unsigned a: 8;
+  unsigned b: 8;
+  unsigned c: 8;
+  unsigned d: 8;
+};
+
+struct thing2 {
+  volatile unsigned a: 8;
+  volatile unsigned b: 8;
+  volatile unsigned c: 8;
+  volatile unsigned d: 8;
+};
+
+void test1(volatile struct thing *t)
+{
+  t->a = 5;
+}
+
+void test2(struct thing2 *t)
+{
+  t->a = 5;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-1.c	2012-05-14 21:32:29.729958000 +0000
@@ -14,6 +14,6 @@
     c[i] = a[i] * b[i+3];
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movups256/1" } } */
-/* { dg-final { scan-assembler "\\*avx_movups/1" } } */
+/* { dg-final { scan-assembler-not "avx_movups256/1" } } */
+/* { dg-final { scan-assembler "avx_movups/1" } } */
 /* { dg-final { scan-assembler "vinsertf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-2.c	2012-05-14 21:32:29.729958000 +0000
@@ -24,6 +24,6 @@
     }
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movdqu256/1" } } */
-/* { dg-final { scan-assembler "\\*avx_movdqu/1" } } */
+/* { dg-final { scan-assembler-not "avx_movdqu256/1" } } */
+/* { dg-final { scan-assembler "avx_movdqu/1" } } */
 /* { dg-final { scan-assembler "vinsertf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-3.c	2012-05-14 21:32:29.729958000 +0000
@@ -14,6 +14,6 @@
     c[i] = a[i] * b[i+3];
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movupd256/1" } } */
-/* { dg-final { scan-assembler "\\*avx_movupd/1" } } */
+/* { dg-final { scan-assembler-not "avx_movupd256/1" } } */
+/* { dg-final { scan-assembler "avx_movupd/1" } } */
 /* { dg-final { scan-assembler "vinsertf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c	2012-05-14 21:32:29.729958000 +0000
@@ -14,6 +14,6 @@
     b[i] = a[i+3] * 2;
 }
 
-/* { dg-final { scan-assembler "\\*avx_movups256/1" } } */
-/* { dg-final { scan-assembler-not "\\*avx_movups/1" } } */
+/* { dg-final { scan-assembler "avx_movups256/1" } } */
+/* { dg-final { scan-assembler-not "avx_movups/1" } } */
 /* { dg-final { scan-assembler-not "vinsertf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c	2012-05-14 21:32:29.729958000 +0000
@@ -17,6 +17,6 @@
     d[i] = c[i] * 20.0;
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movups256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movups256/2" } } */
 /* { dg-final { scan-assembler "movups.*\\*avx_movv4sf_internal/3" } } */
 /* { dg-final { scan-assembler "vextractf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-2.c	2012-05-14 21:32:29.729958000 +0000
@@ -24,6 +24,6 @@
     }
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movdqu256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movdqu256/2" } } */
 /* { dg-final { scan-assembler "movdqu.*\\*avx_movv16qi_internal/3" } } */
 /* { dg-final { scan-assembler "vextractf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c	2012-05-14 21:32:29.729958000 +0000
@@ -17,6 +17,6 @@
     d[i] = c[i] * 20.0;
 }
 
-/* { dg-final { scan-assembler-not "\\*avx_movupd256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movupd256/2" } } */
 /* { dg-final { scan-assembler "movupd.*\\*avx_movv2df_internal/3" } } */
 /* { dg-final { scan-assembler "vextractf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c	2011-06-28 23:27:06.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c	2012-05-14 21:32:29.729958000 +0000
@@ -14,7 +14,7 @@
     b[i+3] = a[i] * c[i];
 }
 
-/* { dg-final { scan-assembler "\\*avx_movups256/2" } } */
-/* { dg-final { scan-assembler-not "\\*avx_movups/2" } } */
+/* { dg-final { scan-assembler "avx_movups256/2" } } */
+/* { dg-final { scan-assembler-not "avx_movups/2" } } */
 /* { dg-final { scan-assembler-not "\\*avx_movv4sf_internal/3" } } */
 /* { dg-final { scan-assembler-not "vextractf128" } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/pr52736.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/pr52736.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/pr52736.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/pr52736.c	2012-03-28 08:09:55.449307000 +0000
@@ -0,0 +1,29 @@
+/* PR target/52736 */
+/* { dg-do run } */
+/* { dg-options "-O1 -msse2" } */
+/* { dg-require-effective-target sse2_runtime } */
+
+#include <x86intrin.h>
+
+typedef double D __attribute__((may_alias));
+__attribute__((aligned(16))) static const double r[4] = { 1., 5., 1., 3. };
+
+__attribute__((noinline, noclone))
+void
+foo (int x)
+{
+  asm volatile ("" : "+g" (x) : : "memory");
+  if (x != 3)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  __m128d t = _mm_set1_pd (5.);
+  ((D *)(&t))[0] = 1.;
+  foo (_mm_movemask_pd (_mm_cmpeq_pd (t, _mm_load_pd (&r[0]))));
+  ((D *)(&t))[1] = 3.;
+  foo (_mm_movemask_pd (_mm_cmpeq_pd (t, _mm_load_pd (&r[2]))));
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/pr53416.c gcc-4.6.3/gcc/testsuite/gcc.target/i386/pr53416.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/i386/pr53416.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/i386/pr53416.c	2012-05-21 12:59:53.696085000 +0000
@@ -0,0 +1,17 @@
+/* PR target/53416 */
+/* { dg-options "-O2 -mrdrnd" } */
+
+int test (void)
+{
+  unsigned int number = 0;
+  int result0, result1, result2, result3;
+
+  result0 = __builtin_ia32_rdrand32_step (&number);
+  result1 = __builtin_ia32_rdrand32_step (&number);
+  result2 = __builtin_ia32_rdrand32_step (&number);
+  result3 = __builtin_ia32_rdrand32_step (&number);
+
+  return result0 + result1 +result2 + result3;
+}
+
+/* { dg-final { scan-assembler-times "rdrand" 4 } } */
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-1.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-1.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-1.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-1.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvlx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc1(long a, void *p)           { return __builtin_altivec_lvlx (a,p); }
+vsf  llx01(long a, vsf *p)          { return __builtin_vec_lvlx (a,p); }
+vsf  llx02(long a, sf *p)           { return __builtin_vec_lvlx (a,p); }
+vbi  llx03(long a, vbi *p)          { return __builtin_vec_lvlx (a,p); }
+vsi  llx04(long a, vsi *p)          { return __builtin_vec_lvlx (a,p); }
+vsi  llx05(long a, si *p)           { return __builtin_vec_lvlx (a,p); }
+vui  llx06(long a, vui *p)          { return __builtin_vec_lvlx (a,p); }
+vui  llx07(long a, ui *p)           { return __builtin_vec_lvlx (a,p); }
+vbs  llx08(long a, vbs *p)          { return __builtin_vec_lvlx (a,p); }
+vp   llx09(long a, vp *p)           { return __builtin_vec_lvlx (a,p); }
+vss  llx10(long a, vss *p)          { return __builtin_vec_lvlx (a,p); }
+vss  llx11(long a, ss *p)           { return __builtin_vec_lvlx (a,p); }
+vus  llx12(long a, vus *p)          { return __builtin_vec_lvlx (a,p); }
+vus  llx13(long a, us *p)           { return __builtin_vec_lvlx (a,p); }
+vbc  llx14(long a, vbc *p)          { return __builtin_vec_lvlx (a,p); }
+vsc  llx15(long a, vsc *p)          { return __builtin_vec_lvlx (a,p); }
+vsc  llx16(long a, sc *p)           { return __builtin_vec_lvlx (a,p); }
+vuc  llx17(long a, vuc *p)          { return __builtin_vec_lvlx (a,p); }
+vuc  llx18(long a, uc *p)           { return __builtin_vec_lvlx (a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-2.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-2.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-2.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-2.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvlxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc2(long a, void *p)           { return __builtin_altivec_lvlxl (a,p); }
+vsf  llxl01(long a, vsf *p)         { return __builtin_vec_lvlxl (a,p); }
+vsf  llxl02(long a, sf *p)          { return __builtin_vec_lvlxl (a,p); }
+vbi  llxl03(long a, vbi *p)         { return __builtin_vec_lvlxl (a,p); }
+vsi  llxl04(long a, vsi *p)         { return __builtin_vec_lvlxl (a,p); }
+vsi  llxl05(long a, si *p)          { return __builtin_vec_lvlxl (a,p); }
+vui  llxl06(long a, vui *p)         { return __builtin_vec_lvlxl (a,p); }
+vui  llxl07(long a, ui *p)          { return __builtin_vec_lvlxl (a,p); }
+vbs  llxl08(long a, vbs *p)         { return __builtin_vec_lvlxl (a,p); }
+vp   llxl09(long a, vp *p)          { return __builtin_vec_lvlxl (a,p); }
+vss  llxl10(long a, vss *p)         { return __builtin_vec_lvlxl (a,p); }
+vss  llxl11(long a, ss *p)          { return __builtin_vec_lvlxl (a,p); }
+vus  llxl12(long a, vus *p)         { return __builtin_vec_lvlxl (a,p); }
+vus  llxl13(long a, us *p)          { return __builtin_vec_lvlxl (a,p); }
+vbc  llxl14(long a, vbc *p)         { return __builtin_vec_lvlxl (a,p); }
+vsc  llxl15(long a, vsc *p)         { return __builtin_vec_lvlxl (a,p); }
+vsc  llxl16(long a, sc *p)          { return __builtin_vec_lvlxl (a,p); }
+vuc  llxl17(long a, vuc *p)         { return __builtin_vec_lvlxl (a,p); }
+vuc  llxl18(long a, uc *p)          { return __builtin_vec_lvlxl (a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-3.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-3.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-3.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-3.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvrx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc3(long a, void *p)           { return __builtin_altivec_lvrx (a,p); }
+vsf  lrx01(long a, vsf *p)          { return __builtin_vec_lvrx (a,p); }
+vsf  lrx02(long a, sf *p)           { return __builtin_vec_lvrx (a,p); }
+vbi  lrx03(long a, vbi *p)          { return __builtin_vec_lvrx (a,p); }
+vsi  lrx04(long a, vsi *p)          { return __builtin_vec_lvrx (a,p); }
+vsi  lrx05(long a, si *p)           { return __builtin_vec_lvrx (a,p); }
+vui  lrx06(long a, vui *p)          { return __builtin_vec_lvrx (a,p); }
+vui  lrx07(long a, ui *p)           { return __builtin_vec_lvrx (a,p); }
+vbs  lrx08(long a, vbs *p)          { return __builtin_vec_lvrx (a,p); }
+vp   lrx09(long a, vp *p)           { return __builtin_vec_lvrx (a,p); }
+vss  lrx10(long a, vss *p)          { return __builtin_vec_lvrx (a,p); }
+vss  lrx11(long a, ss *p)           { return __builtin_vec_lvrx (a,p); }
+vus  lrx12(long a, vus *p)          { return __builtin_vec_lvrx (a,p); }
+vus  lrx13(long a, us *p)           { return __builtin_vec_lvrx (a,p); }
+vbc  lrx14(long a, vbc *p)          { return __builtin_vec_lvrx (a,p); }
+vsc  lrx15(long a, vsc *p)          { return __builtin_vec_lvrx (a,p); }
+vsc  lrx16(long a, sc *p)           { return __builtin_vec_lvrx (a,p); }
+vuc  lrx17(long a, vuc *p)          { return __builtin_vec_lvrx (a,p); }
+vuc  lrx18(long a, uc *p)           { return __builtin_vec_lvrx (a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-4.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-4.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-4.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-4.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "lvrxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+vsc  lc4(long a, void *p)           { return __builtin_altivec_lvrxl (a,p); }
+vsf  lrxl01(long a, vsf *p)         { return __builtin_vec_lvrxl (a,p); }
+vsf  lrxl02(long a, sf *p)          { return __builtin_vec_lvrxl (a,p); }
+vbi  lrxl03(long a, vbi *p)         { return __builtin_vec_lvrxl (a,p); }
+vsi  lrxl04(long a, vsi *p)         { return __builtin_vec_lvrxl (a,p); }
+vsi  lrxl05(long a, si *p)          { return __builtin_vec_lvrxl (a,p); }
+vui  lrxl06(long a, vui *p)         { return __builtin_vec_lvrxl (a,p); }
+vui  lrxl07(long a, ui *p)          { return __builtin_vec_lvrxl (a,p); }
+vbs  lrxl08(long a, vbs *p)         { return __builtin_vec_lvrxl (a,p); }
+vp   lrxl09(long a, vp *p)          { return __builtin_vec_lvrxl (a,p); }
+vss  lrxl10(long a, vss *p)         { return __builtin_vec_lvrxl (a,p); }
+vss  lrxl11(long a, ss *p)          { return __builtin_vec_lvrxl (a,p); }
+vus  lrxl12(long a, vus *p)         { return __builtin_vec_lvrxl (a,p); }
+vus  lrxl13(long a, us *p)          { return __builtin_vec_lvrxl (a,p); }
+vbc  lrxl14(long a, vbc *p)         { return __builtin_vec_lvrxl (a,p); }
+vsc  lrxl15(long a, vsc *p)         { return __builtin_vec_lvrxl (a,p); }
+vsc  lrxl16(long a, sc *p)          { return __builtin_vec_lvrxl (a,p); }
+vuc  lrxl17(long a, vuc *p)         { return __builtin_vec_lvrxl (a,p); }
+vuc  lrxl18(long a, uc *p)          { return __builtin_vec_lvrxl (a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-5.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-5.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-5.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-5.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvlx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc1(vsc v, long a, void *p)    { __builtin_altivec_stvlx (v,a,p); }
+void slx01(vsf v, long a, vsf *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx02(vsf v, long a, sf *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx03(vbi v, long a, vbi *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx04(vsi v, long a, vsi *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx05(vsi v, long a, si *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx06(vui v, long a, vui *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx07(vui v, long a, ui *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx08(vbs v, long a, vbs *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx09(vp v, long a, vp *p)     { __builtin_vec_stvlx (v,a,p); }
+void slx10(vss v, long a, vss *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx11(vss v, long a, ss *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx12(vus v, long a, vus *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx13(vus v, long a, us *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx14(vbc v, long a, vbc *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx15(vsc v, long a, vsc *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx16(vsc v, long a, sc *p)    { __builtin_vec_stvlx (v,a,p); }
+void slx17(vuc v, long a, vuc *p)   { __builtin_vec_stvlx (v,a,p); }
+void slx18(vuc v, long a, uc *p)    { __builtin_vec_stvlx (v,a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-6.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-6.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-6.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-6.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvlxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc2(vsc v, long a, void *p)    { __builtin_altivec_stvlxl (v,a,p); }
+void slxl01(vsf v, long a, vsf *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl02(vsf v, long a, sf *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl03(vbi v, long a, vbi *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl04(vsi v, long a, vsi *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl05(vsi v, long a, si *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl06(vui v, long a, vui *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl07(vui v, long a, ui *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl08(vbs v, long a, vbs *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl09(vp v, long a, vp *p)    { __builtin_vec_stvlxl (v,a,p); }
+void slxl10(vss v, long a, vss *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl11(vss v, long a, ss *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl12(vus v, long a, vus *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl13(vus v, long a, us *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl14(vbc v, long a, vbc *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl15(vsc v, long a, vsc *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl16(vsc v, long a, sc *p)   { __builtin_vec_stvlxl (v,a,p); }
+void slxl17(vuc v, long a, vuc *p)  { __builtin_vec_stvlxl (v,a,p); }
+void slxl18(vuc v, long a, uc *p)   { __builtin_vec_stvlxl (v,a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-7.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-7.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-7.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-7.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvrx" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc3(vsc v, long a, void *p)    { __builtin_altivec_stvrx (v,a,p); }
+void srx01(vsf v, long a, vsf *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx02(vsf v, long a, sf *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx03(vbi v, long a, vbi *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx04(vsi v, long a, vsi *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx05(vsi v, long a, si *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx06(vui v, long a, vui *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx07(vui v, long a, ui *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx08(vbs v, long a, vbs *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx09(vp v, long a, vp *p)     { __builtin_vec_stvrx (v,a,p); }
+void srx10(vss v, long a, vss *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx11(vss v, long a, ss *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx12(vus v, long a, vus *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx13(vus v, long a, us *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx14(vbc v, long a, vbc *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx15(vsc v, long a, vsc *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx16(vsc v, long a, sc *p)    { __builtin_vec_stvrx (v,a,p); }
+void srx17(vuc v, long a, vuc *p)   { __builtin_vec_stvrx (v,a,p); }
+void srx18(vuc v, long a, uc *p)    { __builtin_vec_stvrx (v,a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-8.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-8.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/cell_builtin-8.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/cell_builtin-8.c	2012-06-04 17:42:25.267281000 +0000
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mcpu=cell" } */
+/* { dg-final { scan-assembler-times "stvrxl" 19 } } */
+
+#include <altivec.h>
+
+typedef __vector signed char vsc;
+typedef __vector signed short vss;
+typedef __vector signed int vsi;
+typedef __vector unsigned char vuc;
+typedef __vector unsigned short vus;
+typedef __vector unsigned int vui;
+typedef __vector bool char vbc;
+typedef __vector bool short vbs;
+typedef __vector bool int vbi;
+typedef __vector float vsf;
+typedef __vector pixel vp;
+typedef signed char sc;
+typedef signed short ss;
+typedef signed int si;
+typedef signed long sl;
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long ul;
+typedef float sf;
+
+void sc4(vsc v, long a, void *p)    { __builtin_altivec_stvrxl (v,a,p); }
+void srxl01(vsf v, long a, vsf *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl02(vsf v, long a, sf *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl03(vbi v, long a, vbi *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl04(vsi v, long a, vsi *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl05(vsi v, long a, si *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl06(vui v, long a, vui *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl07(vui v, long a, ui *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl08(vbs v, long a, vbs *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl09(vp v, long a, vp *p)    { __builtin_vec_stvrxl (v,a,p); }
+void srxl10(vss v, long a, vss *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl11(vss v, long a, ss *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl12(vus v, long a, vus *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl13(vus v, long a, us *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl14(vbc v, long a, vbc *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl15(vsc v, long a, vsc *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl16(vsc v, long a, sc *p)   { __builtin_vec_stvrxl (v,a,p); }
+void srxl17(vuc v, long a, vuc *p)  { __builtin_vec_stvrxl (v,a,p); }
+void srxl18(vuc v, long a, uc *p)   { __builtin_vec_stvrxl (v,a,p); }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/pr52457.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/pr52457.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/pr52457.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/pr52457.c	2012-03-02 22:12:52.237313000 +0000
@@ -0,0 +1,34 @@
+/* { dg-do run { target { powerpc*-*-linux* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-skip-if "" { powerpc*-*-*spe* } { "*" } { "" } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O1 -mcpu=power7" } */
+
+extern void abort (void);
+
+typedef long long T;
+typedef T vl_t __attribute__((vector_size(2 * sizeof (T))));
+
+vl_t
+buggy_func (T x)
+{
+  vl_t w;
+  T *p = (T *)&w;
+  p[0] = p[1] = x;
+  return w;
+}
+
+int
+main(void)
+{
+  vl_t rval;
+  T *pl;
+
+  pl = (T *) &rval;
+  rval = buggy_func (2);
+
+  if (pl[0] != 2 || pl[1] != 2)
+    abort ();
+
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/pr52775.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/pr52775.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/pr52775.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/pr52775.c	2012-04-13 21:55:15.746111000 +0000
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-options "-O1 -mcpu=power4" } */
+/* { dg-final { scan-assembler-times "fcfid" 2 } } */
+
+double
+int_to_double (int *p)
+{
+  return (double)*p;
+}
+
+double
+long_long_to_double (long long *p)
+{
+  return (double)*p;
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/pr53199.c gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/pr53199.c
--- gcc-4.6.3.orig/gcc/testsuite/gcc.target/powerpc/pr53199.c	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gcc.target/powerpc/pr53199.c	2012-05-04 00:31:50.505528000 +0000
@@ -0,0 +1,50 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-options "-O2 -mcpu=power6 -mavoid-indexed-addresses" } */
+/* { dg-final { scan-assembler-times "lwbrx" 6 } } */
+/* { dg-final { scan-assembler-times "stwbrx" 6 } } */
+
+/* PR 51399: bswap gets an error if -mavoid-indexed-addresses was used in
+   creating the two lwbrx instructions.  */
+
+long long
+load64_reverse_1 (long long *p)
+{
+  return __builtin_bswap64 (*p);
+}
+
+long long
+load64_reverse_2 (long long *p)
+{
+  return __builtin_bswap64 (p[1]);
+}
+
+long long
+load64_reverse_3 (long long *p, int i)
+{
+  return __builtin_bswap64 (p[i]);
+}
+
+void
+store64_reverse_1 (long long *p, long long x)
+{
+  *p = __builtin_bswap64 (x);
+}
+
+void
+store64_reverse_2 (long long *p, long long x)
+{
+  p[1] = __builtin_bswap64 (x);
+}
+
+void
+store64_reverse_3 (long long *p, long long x, int i)
+{
+  p[i] = __builtin_bswap64 (x);
+}
+
+long long
+reg_reverse (long long x)
+{
+  return __builtin_bswap64 (x);
+}
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/init_flag_10.f90 gcc-4.6.3/gcc/testsuite/gfortran.dg/init_flag_10.f90
--- gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/init_flag_10.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gfortran.dg/init_flag_10.f90	2012-06-05 13:05:31.580646000 +0000
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-options "-finit-real=NAN" }
+! { dg-add-options ieee }
+! { dg-skip-if "NaN not supported" { spu-*-* } { "*" } { "" } }
+!
+! PR fortran/50619
+!
+! Contributed by Fred Krogh
+!
+! The NaN initialization used to set the associate name to NaN!
+!
+
+module testa2
+type, public ::  test_ty
+  real :: rmult = 1.0e0
+end type test_ty
+
+contains
+  subroutine test(e, var1)
+    type(test_ty) :: e
+    real :: var1, var2 ! Should get NaN initialized
+
+    ! Should be the default value
+    if (e%rmult /= 1.0) call abort ()
+
+    ! Check that NaN initialization is really turned on
+    if (var1 == var1) call abort () 
+    if (var2 == var2) call abort () 
+
+    ! The following was failing:
+    associate (rmult=>e%rmult)
+      if (e%rmult /= 1.0) call abort ()
+    end associate
+  end subroutine test
+end module testa2
+
+program testa1
+  use testa2
+  type(test_ty) :: e
+  real :: var1 ! Should get NaN initialized
+  call test(e, var1)
+  stop
+end program testa1
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/intrinsic_8.f90 gcc-4.6.3/gcc/testsuite/gfortran.dg/intrinsic_8.f90
--- gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/intrinsic_8.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gfortran.dg/intrinsic_8.f90	2012-03-06 17:08:01.409469000 +0000
@@ -0,0 +1,23 @@
+! { dg-do compile }
+!
+! PR fortran/52452
+!
+! Contributed by Roger Ferrer Ibanez
+!
+PROGRAM test_etime
+    IMPLICIT NONE
+    INTRINSIC :: etime
+    REAL(4) :: tarray(1:2)
+    REAL(4) :: result
+
+    CALL etime(tarray, result)
+END PROGRAM test_etime
+
+subroutine test_etime2
+    IMPLICIT NONE
+    INTRINSIC :: etime
+    REAL(4) :: tarray(1:2)
+    REAL(4) :: result
+
+    result = etime(tarray)
+END subroutine test_etime2
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/optional_absent_2.f90 gcc-4.6.3/gcc/testsuite/gfortran.dg/optional_absent_2.f90
--- gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/optional_absent_2.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gfortran.dg/optional_absent_2.f90	2012-07-14 15:24:12.262320000 +0000
@@ -0,0 +1,53 @@
+! { dg-do run }
+!
+! PR fortran/51758
+!
+! Contributed by Mikael Morin
+!
+! Check whether passing NULL() to an elemental procedure works,
+! where NULL() denotes an absent optional argument.
+!
+program p
+
+  integer :: a(2)
+  integer :: b
+
+  a = 0
+  a = foo((/ 1, 1 /), null())
+!  print *, a
+  if (any(a /= 2)) call abort
+
+  a = 0
+  a = bar((/ 1, 1 /), null())
+!  print *, a
+  if (any(a /= 2)) call abort
+
+  b = 0
+  b = bar(1, null())
+!  print *, b
+  if (b /= 2) call abort
+
+contains
+
+  function foo(a, b)
+    integer           :: a(:)
+    integer, optional :: b(:)
+    integer           :: foo(size(a))
+
+    if (present(b)) call abort
+
+    foo = 2
+  end function foo
+
+  elemental function bar(a, b)
+    integer, intent(in)           :: a
+    integer, intent(in), optional :: b
+    integer                       :: bar
+
+    bar = 2
+
+    if (present(b)) bar = 1
+
+  end function bar
+
+end program p
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/pointer_intent_6.f90 gcc-4.6.3/gcc/testsuite/gfortran.dg/pointer_intent_6.f90
--- gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/pointer_intent_6.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gfortran.dg/pointer_intent_6.f90	2012-05-02 12:53:20.873985000 +0000
@@ -0,0 +1,19 @@
+! { dg-do compile }
+!
+! PR fortran/52864
+!
+! Assigning to an intent(in) pointer (which is valid).
+!
+      program test
+         type PoisFFT_Solver3D
+           complex, dimension(:,:,:), &
+                           pointer :: work => null()
+         end type PoisFFT_Solver3D
+      contains
+        subroutine PoisFFT_Solver3D_FullPeriodic(D, p)
+          type(PoisFFT_Solver3D), intent(in) :: D
+          real, intent(in), pointer :: p(:)
+          D%work(i,j,k) = 0.0
+          p = 0.0
+        end subroutine
+      end
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/proc_ptr_34.f90 gcc-4.6.3/gcc/testsuite/gfortran.dg/proc_ptr_34.f90
--- gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/proc_ptr_34.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gfortran.dg/proc_ptr_34.f90	2012-03-10 09:20:22.792570000 +0000
@@ -0,0 +1,79 @@
+! { dg-do compile }
+!
+! PR fortran/52469
+!
+! This was failing as the DECL of the proc pointer "func"
+! was used for the interface of the proc-pointer component "my_f_ptr"
+! rather than the decl of the proc-pointer target
+!
+! Contributed by palott@gmail.com
+!
+
+module ExampleFuncs
+  implicit none
+
+  ! NOTE: "func" is a procedure pointer!
+  pointer :: func
+  interface
+     function func (z)
+        real :: func
+        real, intent (in) :: z
+     end function func
+  end interface
+
+  type Contains_f_ptr
+     procedure (func), pointer, nopass :: my_f_ptr
+  end type Contains_f_ptr
+contains
+
+function f1 (x)
+  real :: f1
+  real, intent (in) :: x
+
+  f1 = 2.0 * x
+
+  return
+end function f1
+
+function f2 (x)
+   real :: f2
+   real, intent (in) :: x
+
+   f2 = 3.0 * x**2
+
+   return
+end function f2
+
+function fancy (func, x)
+   real :: fancy
+   real, intent (in) :: x
+
+   interface AFunc
+      function func (y)
+         real :: func
+         real, intent (in) ::y
+      end function func
+   end interface AFunc
+
+   fancy = func (x) + 3.3 * x
+end function fancy
+
+end module  ExampleFuncs
+
+
+program test_proc_ptr
+  use ExampleFuncs
+  implicit none
+
+  type (Contains_f_ptr), dimension (2) :: NewType
+ 
+  !NewType(1) % my_f_ptr => f1
+  NewType(2) % my_f_ptr => f2
+
+  !write (*, *) NewType(1) % my_f_ptr (3.0), NewType(2) % my_f_ptr (3.0)
+  write (6, *)  NewType(2) % my_f_ptr (3.0) ! < Shall print '27.0'
+
+  stop
+end program test_proc_ptr
+
+! { dg-final { cleanup-modules "examplefuncs" } }
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90 gcc-4.6.3/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90
--- gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90	2012-05-23 19:13:27.735982000 +0000
@@ -0,0 +1,40 @@
+! { dg-do run }
+!
+! PR fortran/53389
+!
+! The program was leaking memory before due to
+! realloc on assignment and nested functions.
+!
+module foo
+  implicit none
+  contains
+
+  function filler(array, val)
+    real, dimension(:), intent(in):: array
+    real, dimension(size(array)):: filler
+    real, intent(in):: val
+
+    filler=val
+
+  end function filler
+end module
+
+program test
+  use foo
+  implicit none
+
+  real, dimension(:), allocatable:: x, y
+  integer, parameter:: N=1000 !*1000
+  integer:: i
+
+!  allocate( x(N) )
+  allocate( y(N) )
+  y=0.0
+
+  do i=1, N
+!    print *,i
+    x=filler(filler(y, real(2*i)), real(i))
+    y=y+x
+  end do
+
+end program test
diff -Naur gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/save_4.f90 gcc-4.6.3/gcc/testsuite/gfortran.dg/save_4.f90
--- gcc-4.6.3.orig/gcc/testsuite/gfortran.dg/save_4.f90	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/gfortran.dg/save_4.f90	2012-06-14 13:11:27.149798000 +0000
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-std=f2003" }
+!
+! PR fortran/53597
+!
+MODULE somemodule
+  IMPLICIT NONE
+  TYPE sometype
+    INTEGER :: i
+    DOUBLE PRECISION, POINTER, DIMENSION(:,:) :: coef => NULL()
+  END TYPE sometype
+  TYPE(sometype) :: somevariable ! { dg-error "Fortran 2008: Implied SAVE for module variable 'somevariable' at .1., needed due to the default initialization" }
+END MODULE somemodule
diff -Naur gcc-4.6.3.orig/gcc/testsuite/lib/target-supports.exp gcc-4.6.3/gcc/testsuite/lib/target-supports.exp
--- gcc-4.6.3.orig/gcc/testsuite/lib/target-supports.exp	2012-02-22 17:38:22.000000000 +0000
+++ gcc-4.6.3/gcc/testsuite/lib/target-supports.exp	2012-08-10 13:26:44.694722000 +0000
@@ -2976,6 +2976,26 @@
     return $et_natural_alignment_64_saved
 }
 
+# Return 1 if all vector types are naturally aligned (aligned to their
+# type-size), 0 otherwise.
+#
+# This won't change for different subtargets so cache the result.
+
+proc check_effective_target_vect_natural_alignment { } {
+    global et_vect_natural_alignment
+
+    if [info exists et_vect_natural_alignment_saved] {
+        verbose "check_effective_target_vect_natural_alignment: using cached result" 2
+    } else {
+        set et_vect_natural_alignment_saved 1
+        if { [check_effective_target_arm_eabi] } {
+            set et_vect_natural_alignment_saved 0
+        }
+    }
+    verbose "check_effective_target_vect_natural_alignment: returning $et_vect_natural_alignment_saved" 2
+    return $et_vect_natural_alignment_saved
+}
+
 # Return 1 if vector alignment (for types of size 32 bit or less) is reachable, 0 otherwise.
 #
 # This won't change for different subtargets so cache the result.
diff -Naur gcc-4.6.3.orig/gcc/toplev.c gcc-4.6.3/gcc/toplev.c
--- gcc-4.6.3.orig/gcc/toplev.c	2011-02-03 08:29:03.000000000 +0000
+++ gcc-4.6.3/gcc/toplev.c	2012-03-29 02:15:29.973365000 +0000
@@ -1326,6 +1326,13 @@
 	   "and -ftree-loop-linear)");
 #endif
 
+  if (flag_strict_volatile_bitfields > 0 && !abi_version_at_least (2))
+    {
+      warning (0, "-fstrict-volatile-bitfields disabled; "
+	       "it is incompatible with ABI versions < 2");
+      flag_strict_volatile_bitfields = 0;
+    }
+
   /* Unrolling all loops implies that standard loop unrolling must also
      be done.  */
   if (flag_unroll_all_loops)
diff -Naur gcc-4.6.3.orig/gcc/tree-inline.c gcc-4.6.3/gcc/tree-inline.c
--- gcc-4.6.3.orig/gcc/tree-inline.c	2011-07-26 07:52:24.000000000 +0000
+++ gcc-4.6.3/gcc/tree-inline.c	2012-03-25 09:39:32.217767000 +0000
@@ -4947,7 +4947,7 @@
 	        if ((e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)
 		  {
 		    if (!e->inline_failed)
-		      cgraph_remove_node_and_inline_clones (e->callee);
+		      cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);
 		    else
 	              cgraph_remove_edge (e);
 		  }
@@ -4957,8 +4957,8 @@
 		    {
 	              if ((e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)
 			{
-		          if (!e->inline_failed)
-		            cgraph_remove_node_and_inline_clones (e->callee);
+		          if (!e->inline_failed && e->callee != id->src_node)
+		            cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);
 			  else
 	                    cgraph_remove_edge (e);
 			}
diff -Naur gcc-4.6.3.orig/gcc/tree-pretty-print.c gcc-4.6.3/gcc/tree-pretty-print.c
--- gcc-4.6.3.orig/gcc/tree-pretty-print.c	2010-11-05 09:00:50.000000000 +0000
+++ gcc-4.6.3/gcc/tree-pretty-print.c	2012-05-31 15:03:37.575990000 +0000
@@ -805,6 +805,8 @@
 	       infer them and MEM_ATTR caching will share MEM_REFs
 	       with differently-typed op0s.  */
 	    && TREE_CODE (TREE_OPERAND (node, 0)) != INTEGER_CST
+	    /* Released SSA_NAMES have no TREE_TYPE.  */
+	    && TREE_TYPE (TREE_OPERAND (node, 0)) != NULL_TREE
 	    /* Same pointer types, but ignoring POINTER_TYPE vs.
 	       REFERENCE_TYPE.  */
 	    && (TREE_TYPE (TREE_TYPE (TREE_OPERAND (node, 0)))
@@ -1171,6 +1173,8 @@
 		     can't infer them and MEM_ATTR caching will share
 		     MEM_REFs with differently-typed op0s.  */
 		  && TREE_CODE (TREE_OPERAND (op0, 0)) != INTEGER_CST
+		  /* Released SSA_NAMES have no TREE_TYPE.  */
+		  && TREE_TYPE (TREE_OPERAND (op0, 0)) != NULL_TREE
 		  /* Same pointer types, but ignoring POINTER_TYPE vs.
 		     REFERENCE_TYPE.  */
 		  && (TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 0)))
diff -Naur gcc-4.6.3.orig/gcc/tree-sra.c gcc-4.6.3/gcc/tree-sra.c
--- gcc-4.6.3.orig/gcc/tree-sra.c	2012-01-05 22:24:45.000000000 +0000
+++ gcc-4.6.3/gcc/tree-sra.c	2012-03-28 18:03:28.014541000 +0000
@@ -2937,7 +2937,13 @@
     }
   else
     {
-      if (access_has_children_p (lacc) && access_has_children_p (racc))
+      if (access_has_children_p (lacc)
+	  && access_has_children_p (racc)
+	  /* When an access represents an unscalarizable region, it usually
+	     represents accesses with variable offset and thus must not be used
+	     to generate new memory accesses.  */
+	  && !lacc->grp_unscalarizable_region
+	  && !racc->grp_unscalarizable_region)
 	{
 	  gimple_stmt_iterator orig_gsi = *gsi;
 	  enum unscalarized_data_handling refreshed;
diff -Naur gcc-4.6.3.orig/gcc/tree-ssa-ccp.c gcc-4.6.3/gcc/tree-ssa-ccp.c
--- gcc-4.6.3.orig/gcc/tree-ssa-ccp.c	2011-09-26 14:08:53.000000000 +0000
+++ gcc-4.6.3/gcc/tree-ssa-ccp.c	2012-07-04 13:56:00.524689000 +0000
@@ -1364,6 +1364,10 @@
       if (!DECL_INITIAL (base)
 	  && (TREE_STATIC (base) || DECL_EXTERNAL (base)))
         return error_mark_node;
+      /* Do not return an error_mark_node DECL_INITIAL.  LTO uses this
+	 as special marker (_not_ zero ...) for its own purposes.  */
+      if (DECL_INITIAL (base) == error_mark_node)
+	return NULL_TREE;
       return DECL_INITIAL (base);
 
     case ARRAY_REF:
diff -Naur gcc-4.6.3.orig/gcc/tree-vect-data-refs.c gcc-4.6.3/gcc/tree-vect-data-refs.c
--- gcc-4.6.3.orig/gcc/tree-vect-data-refs.c	2011-12-12 19:43:06.000000000 +0000
+++ gcc-4.6.3/gcc/tree-vect-data-refs.c	2012-08-10 13:26:44.694722000 +0000
@@ -1019,7 +1019,7 @@
       int misal = DR_MISALIGNMENT (dr);
       tree vectype = STMT_VINFO_VECTYPE (stmt_info);
       misal += negative ? -npeel * dr_size : npeel * dr_size;
-      misal &= GET_MODE_SIZE (TYPE_MODE (vectype)) - 1;
+      misal &= (TYPE_ALIGN (vectype) / BITS_PER_UNIT) - 1;
       SET_DR_MISALIGNMENT (dr, misal);
       return;
     }
diff -Naur gcc-4.6.3.orig/gcc/tree-vect-loop-manip.c gcc-4.6.3/gcc/tree-vect-loop-manip.c
--- gcc-4.6.3.orig/gcc/tree-vect-loop-manip.c	2011-06-04 09:20:00.000000000 +0000
+++ gcc-4.6.3/gcc/tree-vect-loop-manip.c	2012-08-10 13:26:44.694722000 +0000
@@ -2008,7 +2008,7 @@
    If the misalignment of DR is known at compile time:
      addr_mis = int mis = DR_MISALIGNMENT (dr);
    Else, compute address misalignment in bytes:
-     addr_mis = addr & (vectype_size - 1)
+     addr_mis = addr & (vectype_align - 1)
 
    prolog_niters = min (LOOP_NITERS, ((VF - addr_mis/elem_size)&(VF-1))/step)
 
@@ -2065,9 +2065,10 @@
       tree ptr_type = TREE_TYPE (start_addr);
       tree size = TYPE_SIZE (ptr_type);
       tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);
-      tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);
-      tree elem_size_log =
-        build_int_cst (type, exact_log2 (vectype_align/nelements));
+      tree vectype_align_minus_1 = build_int_cst (type, vectype_align - 1);
+      HOST_WIDE_INT elem_size =
+		int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));
+      tree elem_size_log = build_int_cst (type, exact_log2 (elem_size));
       tree nelements_minus_1 = build_int_cst (type, nelements - 1);
       tree nelements_tree = build_int_cst (type, nelements);
       tree byte_misalign;
@@ -2076,10 +2077,10 @@
       new_bb = gsi_insert_seq_on_edge_immediate (pe, new_stmts);
       gcc_assert (!new_bb);
 
-      /* Create:  byte_misalign = addr & (vectype_size - 1)  */
+      /* Create:  byte_misalign = addr & (vectype_align - 1)  */
       byte_misalign =
         fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), 
-                     vectype_size_minus_1);
+                     vectype_align_minus_1);
 
       /* Create:  elem_misalign = byte_misalign / element_size  */
       elem_misalign =
diff -Naur gcc-4.6.3.orig/gcc/tree-vect-loop.c gcc-4.6.3/gcc/tree-vect-loop.c
--- gcc-4.6.3.orig/gcc/tree-vect-loop.c	2011-06-04 09:20:00.000000000 +0000
+++ gcc-4.6.3/gcc/tree-vect-loop.c	2012-03-02 14:51:58.551861000 +0000
@@ -2104,7 +2104,8 @@
           if (stmt_info
               && !STMT_VINFO_RELEVANT_P (stmt_info)
               && (!STMT_VINFO_LIVE_P (stmt_info)
-                  || STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def))
+                  || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))
+	      && !STMT_VINFO_IN_PATTERN_P (stmt_info))
             continue;
 
           if (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))
@@ -2251,11 +2252,19 @@
 	{
 	  gimple stmt = gsi_stmt (si);
 	  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);
+
+	  if (STMT_VINFO_IN_PATTERN_P (stmt_info))
+	    {
+	      stmt = STMT_VINFO_RELATED_STMT (stmt_info);
+	      stmt_info = vinfo_for_stmt (stmt);
+	    }
+
 	  /* Skip stmts that are not vectorized inside the loop.  */
 	  if (!STMT_VINFO_RELEVANT_P (stmt_info)
 	      && (!STMT_VINFO_LIVE_P (stmt_info)
-		  || STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def))
+		  || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info))))
 	    continue;
+
 	  vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) * factor;
 	  /* FIXME: for stmts in the inner-loop in outer-loop vectorization,
 	     some of the "outside" costs are generated inside the outer-loop.  */
diff -Naur gcc-4.6.3.orig/gcc/tree-vect-stmts.c gcc-4.6.3/gcc/tree-vect-stmts.c
--- gcc-4.6.3.orig/gcc/tree-vect-stmts.c	2012-02-10 12:34:17.000000000 +0000
+++ gcc-4.6.3/gcc/tree-vect-stmts.c	2012-03-02 14:51:58.551861000 +0000
@@ -623,6 +623,46 @@
 }
 
 
+/* Model cost for type demotion and promotion operations.  PWR is normally
+   zero for single-step promotions and demotions.  It will be one if 
+   two-step promotion/demotion is required, and so on.  Each additional
+   step doubles the number of instructions required.  */
+
+static void
+vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,
+				    enum vect_def_type *dt, int pwr)
+{
+  int i, tmp;
+  int inside_cost = 0, outside_cost = 0, single_stmt_cost;
+
+  /* The SLP costs were already calculated during SLP tree build.  */
+  if (PURE_SLP_STMT (stmt_info))
+    return;
+
+  single_stmt_cost = vect_get_stmt_cost (vec_promote_demote);
+  for (i = 0; i < pwr + 1; i++)
+    {
+      tmp = (STMT_VINFO_TYPE (stmt_info) == type_promotion_vec_info_type) ?
+	(i + 1) : i;
+      inside_cost += vect_pow2 (tmp) * single_stmt_cost;
+    }
+
+  /* FORNOW: Assuming maximum 2 args per stmts.  */
+  for (i = 0; i < 2; i++)
+    {
+      if (dt[i] == vect_constant_def || dt[i] == vect_external_def)
+        outside_cost += vect_get_stmt_cost (vector_stmt);
+    }
+
+  if (vect_print_dump_info (REPORT_COST))
+    fprintf (vect_dump, "vect_model_promotion_demotion_cost: inside_cost = %d, "
+             "outside_cost = %d .", inside_cost, outside_cost);
+
+  /* Set the costs in STMT_INFO.  */
+  stmt_vinfo_set_inside_of_loop_cost (stmt_info, NULL, inside_cost);
+  stmt_vinfo_set_outside_of_loop_cost (stmt_info, NULL, outside_cost);
+}
+
 /* Function vect_cost_strided_group_size
 
    For strided load or store, return the group_size only if it is the first
@@ -691,7 +731,7 @@
     {
       /* Uses a high and low interleave operation for each needed permute.  */
       inside_cost = ncopies * exact_log2(group_size) * group_size
-        * vect_get_stmt_cost (vector_stmt);
+        * vect_get_stmt_cost (vec_perm);
 
       if (vect_print_dump_info (REPORT_COST))
         fprintf (vect_dump, "vect_model_store_cost: strided group_size = %d .",
@@ -795,7 +835,7 @@
     {
       /* Uses an even and odd extract operations for each needed permute.  */
       inside_cost = ncopies * exact_log2(group_size) * group_size
-	* vect_get_stmt_cost (vector_stmt);
+	* vect_get_stmt_cost (vec_perm);
 
       if (vect_print_dump_info (REPORT_COST))
         fprintf (vect_dump, "vect_model_load_cost: strided group_size = %d .",
@@ -855,7 +895,7 @@
     case dr_explicit_realign:
       {
         *inside_cost += ncopies * (2 * vect_get_stmt_cost (vector_load)
-           + vect_get_stmt_cost (vector_stmt));
+				   + vect_get_stmt_cost (vec_perm));
 
         /* FIXME: If the misalignment remains fixed across the iterations of
            the containing loop, the following cost should be added to the
@@ -863,6 +903,9 @@
         if (targetm.vectorize.builtin_mask_for_load)
           *inside_cost += vect_get_stmt_cost (vector_stmt);
 
+        if (vect_print_dump_info (REPORT_COST))
+          fprintf (vect_dump, "vect_model_load_cost: explicit realign");
+
         break;
       }
     case dr_explicit_realign_optimized:
@@ -886,7 +929,12 @@
           }
 
         *inside_cost += ncopies * (vect_get_stmt_cost (vector_load)
-          + vect_get_stmt_cost (vector_stmt));
+				   + vect_get_stmt_cost (vec_perm));
+
+        if (vect_print_dump_info (REPORT_COST))
+          fprintf (vect_dump,
+		   "vect_model_load_cost: explicit realign optimized");
+
         break;
       }
 
@@ -2919,7 +2967,7 @@
       STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;
       if (vect_print_dump_info (REPORT_DETAILS))
         fprintf (vect_dump, "=== vectorizable_demotion ===");
-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);
+      vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);
       return true;
     }
 
@@ -3217,7 +3265,7 @@
       STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;
       if (vect_print_dump_info (REPORT_DETAILS))
         fprintf (vect_dump, "=== vectorizable_promotion ===");
-      vect_model_simple_cost (stmt_info, 2*ncopies, dt, NULL);
+      vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);
       return true;
     }
 
diff -Naur gcc-4.6.3.orig/gcc/varasm.c gcc-4.6.3/gcc/varasm.c
--- gcc-4.6.3.orig/gcc/varasm.c	2011-12-09 19:11:01.000000000 +0000
+++ gcc-4.6.3/gcc/varasm.c	2012-04-24 06:14:37.854759000 +0000
@@ -1,7 +1,7 @@
 /* Output variables, constants and external declarations, for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
-   2010, 2011  Free Software Foundation, Inc.
+   2010, 2011, 2012  Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -30,6 +30,7 @@
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "pointer-set.h"
 #include "tm.h"
 #include "rtl.h"
 #include "tree.h"
@@ -2097,6 +2098,19 @@
    it all the way to final.  See PR 17982 for further discussion.  */
 static GTY(()) tree pending_assemble_externals;
 
+/* FIXME: Trunk is at GCC 4.8 now and the above problem still hasn't been
+   addressed properly.  This caused PR 52640 due to O(external_decls**2)
+   lookups in the pending_assemble_externals TREE_LIST in assemble_external.
+   Paper over with this pointer set, which we use to see if we have already
+   added a decl to pending_assemble_externals without first traversing
+   the entire pending_assemble_externals list.  See assemble_external().  */
+static struct pointer_set_t *pending_assemble_externals_set;
+
+/* Some targets delay some output to final using TARGET_ASM_FILE_END.
+   As a result, assemble_external can be called after the list of externals
+   is processed and the pointer set destroyed.  */
+static bool pending_assemble_externals_processed;
+
 #ifdef ASM_OUTPUT_EXTERNAL
 /* True if DECL is a function decl for which no out-of-line copy exists.
    It is assumed that DECL's assembler name has been set.  */
@@ -2146,6 +2160,8 @@
     assemble_external_real (TREE_VALUE (list));
 
   pending_assemble_externals = 0;
+  pending_assemble_externals_processed = true;
+  pointer_set_destroy (pending_assemble_externals_set);
 #endif
 }
 
@@ -2186,7 +2202,13 @@
     weak_decls = tree_cons (NULL, decl, weak_decls);
 
 #ifdef ASM_OUTPUT_EXTERNAL
-  if (value_member (decl, pending_assemble_externals) == NULL_TREE)
+  if (pending_assemble_externals_processed)
+    {
+      assemble_external_real (decl);
+      return;
+    }
+
+  if (! pointer_set_insert (pending_assemble_externals_set, decl))
     pending_assemble_externals = tree_cons (NULL, decl,
 					    pending_assemble_externals);
 #endif
@@ -3922,6 +3944,13 @@
 	   tem = TREE_OPERAND (tem, 0))
 	;
 
+      if (TREE_CODE (tem) == MEM_REF
+	  && TREE_CODE (TREE_OPERAND (tem, 0)) == ADDR_EXPR)
+	{
+	  reloc = compute_reloc_for_constant (TREE_OPERAND (tem, 0));
+	  break;
+	}
+
       if (TREE_PUBLIC (tem))
 	reloc |= 2;
       else
@@ -3990,6 +4019,9 @@
 
       if (CONSTANT_CLASS_P (tem) || TREE_CODE (tem) == CONSTRUCTOR)
 	output_constant_def (tem, 0);
+
+      if (TREE_CODE (tem) == MEM_REF)
+	output_addressed_constants (TREE_OPERAND (tem, 0));
       break;
 
     case PLUS_EXPR:
@@ -6019,6 +6051,10 @@
 
   if (readonly_data_section == NULL)
     readonly_data_section = text_section;
+
+#ifdef ASM_OUTPUT_EXTERNAL
+  pending_assemble_externals_set = pointer_set_create ();
+#endif
 }
 
 enum tls_model
diff -Naur gcc-4.6.3.orig/gcc/version.c gcc-4.6.3/gcc/version.c
--- gcc-4.6.3.orig/gcc/version.c	2009-04-21 19:03:23.000000000 +0000
+++ gcc-4.6.3/gcc/version.c	2012-08-25 17:27:00.696732424 +0000
@@ -33,4 +33,4 @@
    Makefile.  */
 
 const char version_string[] = BASEVER DATESTAMP DEVPHASE REVISION;
-const char pkgversion_string[] = PKGVERSION;
+const char pkgversion_string[] = "(GCC for Cross-LFS 4.6.3.20120825) ";
diff -Naur gcc-4.6.3.orig/libffi/src/powerpc/aix.S gcc-4.6.3/libffi/src/powerpc/aix.S
--- gcc-4.6.3.orig/libffi/src/powerpc/aix.S	2009-12-05 21:48:58.000000000 +0000
+++ gcc-4.6.3/libffi/src/powerpc/aix.S	2012-03-22 14:35:34.814561000 +0000
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   aix.S - Copyright (c) 2002,2009 Free Software Foundation, Inc.
+   aix.S - Copyright (c) 2002, 2009 Free Software Foundation, Inc.
    based on darwin.S by John Hornkvist
 
    PowerPC Assembly glue.
@@ -79,6 +79,8 @@
 	.set f20,20
 	.set f21,21
 
+	.extern .ffi_prep_args
+
 #define LIBFFI_ASM
 #include <fficonfig.h>
 #include <ffi.h>
@@ -125,6 +127,7 @@
 	/* Call ffi_prep_args.  */
 	mr	r4, r1
 	bl	.ffi_prep_args
+	nop
 
 	/* Now do the call.  */
 	ld	r0, 0(r29)
@@ -226,6 +229,7 @@
 	/* Call ffi_prep_args.  */
 	mr	r4, r1
 	bl	.ffi_prep_args
+	nop
 
 	/* Now do the call.  */
 	lwz	r0, 0(r29)
diff -Naur gcc-4.6.3.orig/libffi/src/powerpc/aix_closure.S gcc-4.6.3/libffi/src/powerpc/aix_closure.S
--- gcc-4.6.3.orig/libffi/src/powerpc/aix_closure.S	2009-12-08 00:41:10.000000000 +0000
+++ gcc-4.6.3/libffi/src/powerpc/aix_closure.S	2012-03-22 14:35:34.814561000 +0000
@@ -79,6 +79,8 @@
 	.set f20,20
 	.set f21,21
 
+	.extern .ffi_closure_helper_DARWIN
+
 #define LIBFFI_ASM
 #define JUMPTARGET(name) name
 #define L(x) x
@@ -165,6 +167,7 @@
 
 	/* look up the proper starting point in table  */
 	/* by using return type as offset */
+	lhz	r3, 10(r3)	/* load type from return type */
 	ld	r4, LC..60(2)	/* get address of jump table */
 	sldi	r3, r3, 4	/* now multiply return type by 16 */
 	ld	r0, 240+16(r1)	/* load return address */
@@ -337,8 +340,9 @@
 
 	/* look up the proper starting point in table  */
 	/* by using return type as offset */
+	lhz	r3, 6(r3)	/* load type from return type */
 	lwz	r4, LC..60(2)	/* get address of jump table */
-	slwi	r3, r3, 4	/* now multiply return type by 4 */
+	slwi	r3, r3, 4	/* now multiply return type by 16 */
 	lwz	r0, 176+8(r1)	/* load return address */
 	add	r3, r3, r4	/* add contents of table to table address */
 	mtctr	r3
diff -Naur gcc-4.6.3.orig/libgfortran/intrinsics/eoshift2.c gcc-4.6.3/libgfortran/intrinsics/eoshift2.c
--- gcc-4.6.3.orig/libgfortran/intrinsics/eoshift2.c	2009-07-19 15:07:21.000000000 +0000
+++ gcc-4.6.3/libgfortran/intrinsics/eoshift2.c	2012-05-11 22:33:21.046165000 +0000
@@ -77,6 +77,12 @@
 
       ret->offset = 0;
       ret->dtype = array->dtype;
+
+      if (arraysize > 0)
+	ret->data = internal_malloc_size (size * arraysize);
+      else
+	ret->data = internal_malloc_size (1);
+
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
         {
 	  index_type ub, str;
@@ -90,12 +96,6 @@
 	      * GFC_DESCRIPTOR_STRIDE(ret,i-1);
 
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
-
-	  if (arraysize > 0)
-	    ret->data = internal_malloc_size (size * arraysize);
-	  else
-	    ret->data = internal_malloc_size (1);
-
         }
     }
   else if (unlikely (compile_options.bounds_check))
diff -Naur gcc-4.6.3.orig/libjava/configure gcc-4.6.3/libjava/configure
--- gcc-4.6.3.orig/libjava/configure	2012-03-01 12:03:46.000000000 +0000
+++ gcc-4.6.3/libjava/configure	2012-03-02 18:21:41.598223000 +0000
@@ -19775,14 +19775,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
-    *-*-darwin9*)
+    *-*-darwin[912]*)
       SYSTEMSPEC="%{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
     ;;
-    *-*-darwin[12]*)
-      # Something is incompatible with pie, would be nice to fix it and
-      # remove -no_pie.  PR49461
-      SYSTEMSPEC="-no_pie %{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
-    ;;
     *)
       SYSTEMSPEC=
     ;;
diff -Naur gcc-4.6.3.orig/libjava/configure.ac gcc-4.6.3/libjava/configure.ac
--- gcc-4.6.3.orig/libjava/configure.ac	2012-02-03 10:35:06.000000000 +0000
+++ gcc-4.6.3/libjava/configure.ac	2012-03-02 18:21:41.598223000 +0000
@@ -886,14 +886,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
-    *-*-darwin9*)
+    *-*-darwin[[912]]*)
       SYSTEMSPEC="%{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
     ;;
-    *-*-darwin[[12]]*)
-      # Something is incompatible with pie, would be nice to fix it and
-      # remove -no_pie.  PR49461
-      SYSTEMSPEC="-no_pie %{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
-    ;;
     *)
       SYSTEMSPEC=
     ;;
diff -Naur gcc-4.6.3.orig/libquadmath/libquadmath.info gcc-4.6.3/libquadmath/libquadmath.info
--- gcc-4.6.3.orig/libquadmath/libquadmath.info	2012-03-01 12:41:20.000000000 +0000
+++ gcc-4.6.3/libquadmath/libquadmath.info	1970-01-01 00:00:00.000000000 +0000
@@ -1,924 +0,0 @@
-This is libquadmath.info, produced by makeinfo version 4.13 from
-/d//gcc-4.6.3/gcc-4.6.3/libquadmath/libquadmath.texi.
-
-Copyright (C) 2010 Free Software Foundation, Inc.
-
-     Permission is granted to copy, distribute and/or modify this
-     document under the terms of the GNU Free Documentation License,
-     Version 1.2 or any later version published by the Free Software
-     Foundation; with no Invariant Sections, with the Front-Cover Texts
-     being "A GNU Manual," and with the Back-Cover Texts as in (a)
-     below.  A copy of the license is included in the section entitled
-     "GNU Free Documentation License."
-
-     (a) The FSF's Back-Cover Text is: "You have the freedom to copy
-     and modify this GNU manual.
-
-INFO-DIR-SECTION GNU Libraries
-START-INFO-DIR-ENTRY
-* libquadmath: (libquadmath).                  GCC Quad-Precision Math Library
-END-INFO-DIR-ENTRY
-
-   This manual documents the GCC Quad-Precision Math Library API.
-
-   Published by the Free Software Foundation 51 Franklin Street, Fifth
-Floor Boston, MA 02110-1301 USA
-
-   Copyright (C) 2010 Free Software Foundation, Inc.
-
-     Permission is granted to copy, distribute and/or modify this
-     document under the terms of the GNU Free Documentation License,
-     Version 1.2 or any later version published by the Free Software
-     Foundation; with no Invariant Sections, with the Front-Cover Texts
-     being "A GNU Manual," and with the Back-Cover Texts as in (a)
-     below.  A copy of the license is included in the section entitled
-     "GNU Free Documentation License."
-
-     (a) The FSF's Back-Cover Text is: "You have the freedom to copy
-     and modify this GNU manual.
-
-
-File: libquadmath.info,  Node: Top,  Next: Typedef and constants,  Up: (dir)
-
-Introduction
-************
-
-This manual documents the usage of libquadmath, the GCC Quad-Precision
-Math Library Application Programming Interface (API).
-
-* Menu:
-
-* Typedef and constants::      Defined data types and constants
-* Math Library Routines::      The Libquadmath math runtime application
-                               programming interface.
-* I/O Library Routines::       The Libquadmath I/O runtime application
-                               programming interface.
-* GNU Free Documentation License::
-                               How you can copy and share this manual.
-* Reporting Bugs::             How to report bugs in GCC Libquadmath.
-
-
-File: libquadmath.info,  Node: Typedef and constants,  Next: Math Library Routines,  Prev: Top,  Up: Top
-
-1 Typedef and constants
-***********************
-
-The following data type has been defined via `typedef'.
-
-`__complex128': `__float128'-based complex number
-
-   The following macros are defined, which give the numeric limits of
-the `__float128' data type.
-
-`FLT128_MAX': largest finite number
-
-`FLT128_MIN': smallest positive number with full precision
-
-`FLT128_EPSILON': difference between 1 and the next larger
-     representable number
-
-`FLT128_DENORM_MIN': smallest positive denormalized number
-
-`FLT128_MANT_DIG': number of digits in the mantissa (bit precision)
-
-`FLT128_MIN_EXP': maximal negative exponent
-
-`FLT128_MAX_EXP': maximal positive exponent
-
-`FLT128_DIG': number of decimal digits in the mantissa
-
-`FLT128_MIN_10_EXP': maximal negative decimal exponent
-
-`FLT128_MAX_10_EXP': maximal positive decimal exponent
-
-   The following mathematical constants of type `__float128' are
-defined.
-
-`M_Eq': the constant e (Euler's number)
-
-`M_LOG2Eq': binary logarithm of 2
-
-`M_LOG10Eq': common, decimal logarithm of 2
-
-`M_LN2q': natural logarithm of 2
-
-`M_LN10q': natural logarithm of 10
-
-`M_PIq': pi
-
-`M_PI_2q': two pi
-
-`M_PI_4q': four pi
-
-`M_1_PIq': one over pi
-
-`M_2_PIq': one over two pi
-
-`M_2_SQRTPIq': two over square root of pi
-
-`M_SQRT2q': square root of 2
-
-`M_SQRT1_2q': one over square root of 2
-
-
-File: libquadmath.info,  Node: Math Library Routines,  Next: I/O Library Routines,  Prev: Typedef and constants,  Up: Top
-
-2 Math Library Routines
-***********************
-
-The following mathematical functions are available:
-
-`acosq': arc cosine function
-
-`acoshq': inverse hyperbolic cosine function
-
-`asinq': arc sine function
-
-`asinhq': inverse hyperbolic sine function
-
-`atanq': arc tangent function
-
-`atanhq': inverse hyperbolic tangent function
-
-`atan2q': arc tangent function
-
-`cbrtq': cube root function
-
-`ceilq': ceiling value function
-
-`copysignq': copy sign of a number
-
-`coshq': hyperbolic cosine function
-
-`cosq': cosine function
-
-`erfq': error function
-
-`erfcq': complementary error function
-
-`expq': exponential function
-
-`expm1q': exponential minus 1 function
-
-`fabsq': absolute value function
-
-`fdimq': positive difference function
-
-`finiteq': check finiteness of value
-
-`floorq': floor value function
-
-`fmaq': fused multiply and add
-
-`fmaxq': determine maximum of two values
-
-`fminq': determine minimum of two values
-
-`fmodq': remainder value function
-
-`frexpq': extract mantissa and exponent
-
-`hypotq': Eucledian distance function
-
-`ilogbq': get exponent of the value
-
-`isinfq': check for infinity
-
-`isnanq': check for not a number
-
-`j0q': Bessel function of the first kind, first order
-
-`j1q': Bessel function of the first kind, second order
-
-`jnq': Bessel function of the first kind, N-th order
-
-`ldexpq': load exponent of the value
-
-`lgammaq': logarithmic gamma function
-
-`llrintq': round to nearest integer value
-
-`llroundq': round to nearest integer value away from zero
-
-`logq': natural logarithm function
-
-`log10q': base 10 logarithm function
-
-`log1pq': compute natural logarithm of the value plus one
-
-`log2q': base 2 logarithm function
-
-`lrintq': round to nearest integer value
-
-`lroundq': round to nearest integer value away from zero
-
-`modfq': decompose the floating-point number
-
-`nanq': return quiet NaN
-
-`nearbyintq': round to nearest integer
-
-`nextafterq': next representable floating-point number
-
-`powq': power function
-
-`remainderq': remainder function
-
-`remquoq': remainder and part of quotient
-
-`rintq': round-to-nearest integral value
-
-`roundq': round-to-nearest integral value, return `__float128'
-
-`scalblnq': compute exponent using `FLT_RADIX'
-
-`scalbnq': compute exponent using `FLT_RADIX'
-
-`signbitq': return sign bit
-
-`sincosq': calculate sine and cosine simulataneously
-
-`sinhq': hyperbolic sine function
-
-`sinq': sine function
-
-`sqrtq': square root function
-
-`tanq': tangent function
-
-`tanhq': hyperbolic tangent function
-
-`tgammaq': true gamma function
-
-`truncq': round to integer, towards zero
-
-`y0q': Bessel function of the second kind, first order
-
-`y1q': Bessel function of the second kind, second order
-
-`ynq': Bessel function of the second kind, N-th order
-
-`cabsq' complex absolute value function
-
-`cargq': calculate the argument
-
-`cimagq' imaginary part of complex number
-
-`crealq': real part of complex number
-
-`cacoshq': complex arc hyperbolic cosine function
-
-`cacosq': complex arc cosine function
-
-`casinhq': complex arc hyperbolic sine function
-
-`casinq': complex arc sine function
-
-`catanhq': complex arc hyperbolic tangent function
-
-`catanq': complex arc tangent function
-
-`ccosq' complex cosine function:
-
-`ccoshq': complex hyperbolic cosine function
-
-`cexpq': complex exponential function
-
-`cexpiq': computes the exponential function of "i" times a
-     real value
-
-`clogq': complex natural logarithm
-
-`clog10q': complex base 10 logarithm
-
-`conjq': complex conjugate function
-
-`cpowq': complex power function
-
-`cprojq': project into Riemann Sphere
-
-`csinq': complex sine function
-
-`csinhq': complex hyperbolic sine function
-
-`csqrtq': complex square root
-
-`ctanq': complex tangent function
-
-`ctanhq': complex hyperbolic tangent function
-
-
-File: libquadmath.info,  Node: I/O Library Routines,  Next: GNU Free Documentation License,  Prev: Math Library Routines,  Up: Top
-
-3 I/O Library Routines
-**********************
-
-* Menu:
-
-* `strtoflt128':          strtoflt128,          Convert from string
-* `quadmath_snprintf':    quadmath_snprintf,    Convert to string
-
-
-File: libquadmath.info,  Node: strtoflt128,  Next: quadmath_snprintf,  Up: I/O Library Routines
-
-3.1 `strtoflt128' -- Convert from string
-========================================
-
-The function `dmath_strtopQ' converts a string into a `__float128'
-number.
-
-Syntax
-     `__float128 strtoflt128 (const char *s, char **sp)'
-
-_Arguments_:
-     S          input string
-     SP         the address of the next character in the string
-
-     The argument SP contains, if not `NULL', the address of the next
-     character following the parts of the string, which have been read.
-
-Example
-          #include <quadmath.h>
-
-          int main ()
-          {
-            __float128 r;
-
-            r = strtoflt128 ("1.2345678", NULL);
-
-            return 0;
-          }
-
-
-File: libquadmath.info,  Node: quadmath_snprintf,  Prev: strtoflt128,  Up: I/O Library Routines
-
-3.2 `quadmath_snprintf' -- Convert to string
-============================================
-
-The function `quadmath_snprintf' converts a `__float128' floating-point
-number into a string.  It is a specialized alternative to `snprintf',
-where the format string is restricted to a single conversion specifier
-with `Q' modifier and conversion specifier `e', `E', `f', `F', `g',
-`G', `a' or `A', with no extra characters before or after the
-conversion specifier.  The `%m$' or `*m$' style must not be used in the
-format.
-
-Syntax
-     `int quadmath_snprintf (char *s, size_t size, const char *format,
-     ...)'
-
-_Arguments_:
-     S          output string
-     SIZE       byte size of the string, including tailing NUL
-     FORMAT     conversion specifier string
-
-Example
-          #include <quadmath.h>
-          #include <stdlib.h>
-          #include <stdio.h>
-
-          int main ()
-          {
-            __float128 r;
-            int prec = 20;
-            int width = 46;
-            char buf[128];
-
-            r = 2.0q;
-            r = sqrtq (r);
-            int n = quadmath_snprintf (buf, sizeof buf, "%+-#*.20Qe", width, r);
-            if ((size_t) n < sizeof buf)
-              printf ("%s\n", buf);
-              /* Prints: +1.41421356237309504880e+00 */
-            quadmath_snprintf (buf, sizeof buf, "%Qa", r);
-            if ((size_t) n < sizeof buf)
-              printf ("%s\n", buf);
-              /* Prints: 0x1.6a09e667f3bcc908b2fb1366ea96p+0 */
-            n = quadmath_snprintf (NULL, 0, "%+-#46.*Qe", prec, r);
-            if (n > -1)
-              {
-                char *str = malloc (n + 1);
-                if (str)
-                  {
-                    quadmath_snprintf (str, n + 1, "%+-#46.*Qe", prec, r);
-                    printf ("%s\n", str);
-                    /* Prints: +1.41421356237309504880e+00 */
-                  }
-                free (str);
-              }
-            return 0;
-          }
-
-
-   On some targets when supported by the C library hooks are installed
-for `printf' family of functions, so that `printf ("%Qe", 1.2Q);' etc.
-works too.
-
-
-File: libquadmath.info,  Node: GNU Free Documentation License,  Next: Reporting Bugs,  Prev: I/O Library Routines,  Up: Top
-
-GNU Free Documentation License
-******************************
-
-                     Version 1.3, 3 November 2008
-
-     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
-     `http://fsf.org/'
-
-     Everyone is permitted to copy and distribute verbatim copies
-     of this license document, but changing it is not allowed.
-
-  0. PREAMBLE
-
-     The purpose of this License is to make a manual, textbook, or other
-     functional and useful document "free" in the sense of freedom: to
-     assure everyone the effective freedom to copy and redistribute it,
-     with or without modifying it, either commercially or
-     noncommercially.  Secondarily, this License preserves for the
-     author and publisher a way to get credit for their work, while not
-     being considered responsible for modifications made by others.
-
-     This License is a kind of "copyleft", which means that derivative
-     works of the document must themselves be free in the same sense.
-     It complements the GNU General Public License, which is a copyleft
-     license designed for free software.
-
-     We have designed this License in order to use it for manuals for
-     free software, because free software needs free documentation: a
-     free program should come with manuals providing the same freedoms
-     that the software does.  But this License is not limited to
-     software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
-     instruction or reference.
-
-  1. APPLICABILITY AND DEFINITIONS
-
-     This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
-     grants a world-wide, royalty-free license, unlimited in duration,
-     to use that work under the conditions stated herein.  The
-     "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
-
-     A "Modified Version" of the Document means any work containing the
-     Document or a portion of it, either copied verbatim, or with
-     modifications and/or translated into another language.
-
-     A "Secondary Section" is a named appendix or a front-matter section
-     of the Document that deals exclusively with the relationship of the
-     publishers or authors of the Document to the Document's overall
-     subject (or to related matters) and contains nothing that could
-     fall directly within that overall subject.  (Thus, if the Document
-     is in part a textbook of mathematics, a Secondary Section may not
-     explain any mathematics.)  The relationship could be a matter of
-     historical connection with the subject or with related matters, or
-     of legal, commercial, philosophical, ethical or political position
-     regarding them.
-
-     The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
-
-     The "Cover Texts" are certain short passages of text that are
-     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
-     that says that the Document is released under this License.  A
-     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
-     be at most 25 words.
-
-     A "Transparent" copy of the Document means a machine-readable copy,
-     represented in a format whose specification is available to the
-     general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
-
-     Examples of suitable formats for Transparent copies include plain
-     ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
-
-     The "Title Page" means, for a printed book, the title page itself,
-     plus such following pages as are needed to hold, legibly, the
-     material this License requires to appear in the title page.  For
-     works in formats which do not have any title page as such, "Title
-     Page" means the text near the most prominent appearance of the
-     work's title, preceding the beginning of the body of the text.
-
-     The "publisher" means any person or entity that distributes copies
-     of the Document to the public.
-
-     A section "Entitled XYZ" means a named subunit of the Document
-     whose title either is precisely XYZ or contains XYZ in parentheses
-     following text that translates XYZ in another language.  (Here XYZ
-     stands for a specific section name mentioned below, such as
-     "Acknowledgements", "Dedications", "Endorsements", or "History".)
-     To "Preserve the Title" of such a section when you modify the
-     Document means that it remains a section "Entitled XYZ" according
-     to this definition.
-
-     The Document may include Warranty Disclaimers next to the notice
-     which states that this License applies to the Document.  These
-     Warranty Disclaimers are considered to be included by reference in
-     this License, but only as regards disclaiming warranties: any other
-     implication that these Warranty Disclaimers may have is void and
-     has no effect on the meaning of this License.
-
-  2. VERBATIM COPYING
-
-     You may copy and distribute the Document in any medium, either
-     commercially or noncommercially, provided that this License, the
-     copyright notices, and the license notice saying this License
-     applies to the Document are reproduced in all copies, and that you
-     add no other conditions whatsoever to those of this License.  You
-     may not use technical measures to obstruct or control the reading
-     or further copying of the copies you make or distribute.  However,
-     you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
-
-     You may also lend copies, under the same conditions stated above,
-     and you may publicly display copies.
-
-  3. COPYING IN QUANTITY
-
-     If you publish printed copies (or copies in media that commonly
-     have printed covers) of the Document, numbering more than 100, and
-     the Document's license notice requires Cover Texts, you must
-     enclose the copies in covers that carry, clearly and legibly, all
-     these Cover Texts: Front-Cover Texts on the front cover, and
-     Back-Cover Texts on the back cover.  Both covers must also clearly
-     and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
-
-     If the required texts for either cover are too voluminous to fit
-     legibly, you should put the first ones listed (as many as fit
-     reasonably) on the actual cover, and continue the rest onto
-     adjacent pages.
-
-     If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
-
-     It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
-
-  4. MODIFICATIONS
-
-     You may copy and distribute a Modified Version of the Document
-     under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
-
-       A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
-
-       B. List on the Title Page, as authors, one or more persons or
-          entities responsible for authorship of the modifications in
-          the Modified Version, together with at least five of the
-          principal authors of the Document (all of its principal
-          authors, if it has fewer than five), unless they release you
-          from this requirement.
-
-       C. State on the Title page the name of the publisher of the
-          Modified Version, as the publisher.
-
-       D. Preserve all the copyright notices of the Document.
-
-       E. Add an appropriate copyright notice for your modifications
-          adjacent to the other copyright notices.
-
-       F. Include, immediately after the copyright notices, a license
-          notice giving the public permission to use the Modified
-          Version under the terms of this License, in the form shown in
-          the Addendum below.
-
-       G. Preserve in that license notice the full lists of Invariant
-          Sections and required Cover Texts given in the Document's
-          license notice.
-
-       H. Include an unaltered copy of this License.
-
-       I. Preserve the section Entitled "History", Preserve its Title,
-          and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
-
-       J. Preserve the network location, if any, given in the Document
-          for public access to a Transparent copy of the Document, and
-          likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
-
-       K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
-          acknowledgements and/or dedications given therein.
-
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
-
-       M. Delete any section Entitled "Endorsements".  Such a section
-          may not be included in the Modified Version.
-
-       N. Do not retitle any existing section to be Entitled
-          "Endorsements" or to conflict in title with any Invariant
-          Section.
-
-       O. Preserve any Warranty Disclaimers.
-
-     If the Modified Version includes new front-matter sections or
-     appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
-
-     You may add a section Entitled "Endorsements", provided it contains
-     nothing but endorsements of your Modified Version by various
-     parties--for example, statements of peer review or that the text
-     has been approved by an organization as the authoritative
-     definition of a standard.
-
-     You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
-
-     The author(s) and publisher(s) of the Document do not by this
-     License give permission to use their names for publicity for or to
-     assert or imply endorsement of any Modified Version.
-
-  5. COMBINING DOCUMENTS
-
-     You may combine the Document with other documents released under
-     this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
-     unmodified, and list them all as Invariant Sections of your
-     combined work in its license notice, and that you preserve all
-     their Warranty Disclaimers.
-
-     The combined work need only contain one copy of this License, and
-     multiple identical Invariant Sections may be replaced with a single
-     copy.  If there are multiple Invariant Sections with the same name
-     but different contents, make the title of each such section unique
-     by adding at the end of it, in parentheses, the name of the
-     original author or publisher of that section if known, or else a
-     unique number.  Make the same adjustment to the section titles in
-     the list of Invariant Sections in the license notice of the
-     combined work.
-
-     In the combination, you must combine any sections Entitled
-     "History" in the various original documents, forming one section
-     Entitled "History"; likewise combine any sections Entitled
-     "Acknowledgements", and any sections Entitled "Dedications".  You
-     must delete all sections Entitled "Endorsements."
-
-  6. COLLECTIONS OF DOCUMENTS
-
-     You may make a collection consisting of the Document and other
-     documents released under this License, and replace the individual
-     copies of this License in the various documents with a single copy
-     that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
-
-     You may extract a single document from such a collection, and
-     distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
-
-  7. AGGREGATION WITH INDEPENDENT WORKS
-
-     A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
-     copyright resulting from the compilation is not used to limit the
-     legal rights of the compilation's users beyond what the individual
-     works permit.  When the Document is included in an aggregate, this
-     License does not apply to the other works in the aggregate which
-     are not themselves derivative works of the Document.
-
-     If the Cover Text requirement of section 3 is applicable to these
-     copies of the Document, then if the Document is less than one half
-     of the entire aggregate, the Document's Cover Texts may be placed
-     on covers that bracket the Document within the aggregate, or the
-     electronic equivalent of covers if the Document is in electronic
-     form.  Otherwise they must appear on printed covers that bracket
-     the whole aggregate.
-
-  8. TRANSLATION
-
-     Translation is considered a kind of modification, so you may
-     distribute translations of the Document under the terms of section
-     4.  Replacing Invariant Sections with translations requires special
-     permission from their copyright holders, but you may include
-     translations of some or all Invariant Sections in addition to the
-     original versions of these Invariant Sections.  You may include a
-     translation of this License, and all the license notices in the
-     Document, and any Warranty Disclaimers, provided that you also
-     include the original English version of this License and the
-     original versions of those notices and disclaimers.  In case of a
-     disagreement between the translation and the original version of
-     this License or a notice or disclaimer, the original version will
-     prevail.
-
-     If a section in the Document is Entitled "Acknowledgements",
-     "Dedications", or "History", the requirement (section 4) to
-     Preserve its Title (section 1) will typically require changing the
-     actual title.
-
-  9. TERMINATION
-
-     You may not copy, modify, sublicense, or distribute the Document
-     except as expressly provided under this License.  Any attempt
-     otherwise to copy, modify, sublicense, or distribute it is void,
-     and will automatically terminate your rights under this License.
-
-     However, if you cease all violation of this License, then your
-     license from a particular copyright holder is reinstated (a)
-     provisionally, unless and until the copyright holder explicitly
-     and finally terminates your license, and (b) permanently, if the
-     copyright holder fails to notify you of the violation by some
-     reasonable means prior to 60 days after the cessation.
-
-     Moreover, your license from a particular copyright holder is
-     reinstated permanently if the copyright holder notifies you of the
-     violation by some reasonable means, this is the first time you have
-     received notice of violation of this License (for any work) from
-     that copyright holder, and you cure the violation prior to 30 days
-     after your receipt of the notice.
-
-     Termination of your rights under this section does not terminate
-     the licenses of parties who have received copies or rights from
-     you under this License.  If your rights have been terminated and
-     not permanently reinstated, receipt of a copy of some or all of
-     the same material does not give you any rights to use it.
-
- 10. FUTURE REVISIONS OF THIS LICENSE
-
-     The Free Software Foundation may publish new, revised versions of
-     the GNU Free Documentation License from time to time.  Such new
-     versions will be similar in spirit to the present version, but may
-     differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
-
-     Each version of the License is given a distinguishing version
-     number.  If the Document specifies that a particular numbered
-     version of this License "or any later version" applies to it, you
-     have the option of following the terms and conditions either of
-     that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.  If the Document specifies that a proxy
-     can decide which future versions of this License can be used, that
-     proxy's public statement of acceptance of a version permanently
-     authorizes you to choose that version for the Document.
-
- 11. RELICENSING
-
-     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
-     World Wide Web server that publishes copyrightable works and also
-     provides prominent facilities for anybody to edit those works.  A
-     public wiki that anybody can edit is an example of such a server.
-     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
-     site means any set of copyrightable works thus published on the MMC
-     site.
-
-     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
-     license published by Creative Commons Corporation, a not-for-profit
-     corporation with a principal place of business in San Francisco,
-     California, as well as future copyleft versions of that license
-     published by that same organization.
-
-     "Incorporate" means to publish or republish a Document, in whole or
-     in part, as part of another Document.
-
-     An MMC is "eligible for relicensing" if it is licensed under this
-     License, and if all works that were first published under this
-     License somewhere other than this MMC, and subsequently
-     incorporated in whole or in part into the MMC, (1) had no cover
-     texts or invariant sections, and (2) were thus incorporated prior
-     to November 1, 2008.
-
-     The operator of an MMC Site may republish an MMC contained in the
-     site under CC-BY-SA on the same site at any time before August 1,
-     2009, provided the MMC is eligible for relicensing.
-
-
-ADDENDUM: How to use this License for your documents
-====================================================
-
-To use this License in a document you have written, include a copy of
-the License in the document and put the following copyright and license
-notices just after the title page:
-
-       Copyright (C)  YEAR  YOUR NAME.
-       Permission is granted to copy, distribute and/or modify this document
-       under the terms of the GNU Free Documentation License, Version 1.3
-       or any later version published by the Free Software Foundation;
-       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
-       Texts.  A copy of the license is included in the section entitled ``GNU
-       Free Documentation License''.
-
-   If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
-
-         with the Invariant Sections being LIST THEIR TITLES, with
-         the Front-Cover Texts being LIST, and with the Back-Cover Texts
-         being LIST.
-
-   If you have Invariant Sections without Cover Texts, or some other
-combination of the three, merge those two alternatives to suit the
-situation.
-
-   If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
-
-
-File: libquadmath.info,  Node: Reporting Bugs,  Prev: GNU Free Documentation License,  Up: Top
-
-4 Reporting Bugs
-****************
-
-Bugs in the GCC Quad-Precision Math Library implementation should be
-reported via `http://gcc.gnu.org/bugs.html'.
-
-
-
-Tag Table:
-Node: Top1661
-Node: Typedef and constants2395
-Node: Math Library Routines3813
-Node: I/O Library Routines7618
-Node: strtoflt1287943
-Node: quadmath_snprintf8703
-Node: GNU Free Documentation License10894
-Node: Reporting Bugs36060
-
-End Tag Table
diff -Naur gcc-4.6.3.orig/libstdc++-v3/acinclude.m4 gcc-4.6.3/libstdc++-v3/acinclude.m4
--- gcc-4.6.3.orig/libstdc++-v3/acinclude.m4	2011-10-05 23:09:51.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/acinclude.m4	2012-07-22 16:46:02.814828000 +0000
@@ -3213,6 +3213,58 @@
   ])
 ])
 
+dnl
+dnl Check whether gthreads types can be copy-assigned in C++11 mode.
+dnl
+AC_DEFUN([GLIBCXX_GTHREADS_CXX11_COPY_ASSIGN], [
+
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -std=c++0x -I${toplevel_srcdir}/gcc"
+
+  target_thread_file=`$CXX -v 2>&1 | sed -n 's/^Thread model: //p'`
+  case $target_thread_file in
+    posix)
+      CXXFLAGS="$CXXFLAGS -DSUPPORTS_WEAK -DGTHREAD_USE_WEAK -D_PTHREADS"
+  esac
+
+  AC_MSG_CHECKING([whether gthreads types are copy-assignable in C++11 mode])
+
+  AC_TRY_COMPILE([#include "gthr.h"],
+    [
+      #ifdef __GTHREAD_MUTEX_INIT
+      __gthread_mutex_t m1;
+      __gthread_mutex_t m2 = __GTHREAD_MUTEX_INIT;
+      m1 = m2;
+      #endif
+      #ifdef __GTHREAD_RECURSIVE_MUTEX_INIT
+      __gthread_recursive_mutex_t r1;
+      __gthread_recursive_mutex_t r2 = __GTHREAD_RECURSIVE_MUTEX_INIT;
+      r1 = r2;
+      #endif
+      #ifdef __GTHREAD_HAS_COND
+      #ifdef __GTHREAD_COND_INIT
+      __gthread_cond_t c1;
+      __gthread_cond_t c2 = __GTHREAD_COND_INIT;
+      c1 = c2;
+      #endif
+      #endif
+    ], [ac_gthread_cxx11_copy_assign=1], [ac_gthread_cxx11_copy_assign=0])
+
+  if test $ac_gthread_cxx11_copy_assign = 1 ; then res_gthr_copy_assign=yes ;
+  else res_gthr_copy_assign=no ; fi
+  AC_MSG_RESULT([$res_gthr_copy_assign])
+
+  if test x"$res_gthr_copy_assign" = x"no"; then
+    AC_DEFINE(_GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11, 1,
+	      [Define if gthreads types cannot be copy-assigned in C++11.])
+  fi
+
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  AC_LANG_RESTORE
+])
+
 # Macros from the top-level gcc directory.
 m4_include([../config/gc++filt.m4])
 m4_include([../config/tls.m4])
diff -Naur gcc-4.6.3.orig/libstdc++-v3/config/os/bsd/netbsd/ctype_base.h gcc-4.6.3/libstdc++-v3/config/os/bsd/netbsd/ctype_base.h
--- gcc-4.6.3.orig/libstdc++-v3/config/os/bsd/netbsd/ctype_base.h	2011-01-30 22:39:36.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/config/os/bsd/netbsd/ctype_base.h	2012-06-20 08:30:55.151768000 +0000
@@ -1,6 +1,6 @@
 // Locale support -*- C++ -*-
 
-// Copyright (C) 2000, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2000, 2009, 2011, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -31,8 +31,6 @@
 //   anoncvs@anoncvs.netbsd.org:/cvsroot/basesrc/include/ctype.h
 // See www.netbsd.org for details of access.
   
-#include <sys/param.h>
-
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -47,7 +45,7 @@
     // on the mask type. Because of this, we don't use an enum.
     typedef unsigned char      	mask;
 
-#if __NetBSD_Version__ < 599004100
+#ifndef _CTYPE_U
     static const mask upper    	= _U;
     static const mask lower 	= _L;
     static const mask alpha 	= _U | _L;
diff -Naur gcc-4.6.3.orig/libstdc++-v3/config.h.in gcc-4.6.3/libstdc++-v3/config.h.in
--- gcc-4.6.3.orig/libstdc++-v3/config.h.in	2010-07-27 10:36:50.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/config.h.in	2012-07-22 16:46:02.814828000 +0000
@@ -692,6 +692,9 @@
 /* Define if a fully dynamic basic_string is wanted. */
 #undef _GLIBCXX_FULLY_DYNAMIC_STRING
 
+/* Define if gthreads types cannot be copy-assigned in C++11. */
+#undef _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+
 /* Define if gthreads library is available. */
 #undef _GLIBCXX_HAS_GTHREADS
 
diff -Naur gcc-4.6.3.orig/libstdc++-v3/configure gcc-4.6.3/libstdc++-v3/configure
--- gcc-4.6.3.orig/libstdc++-v3/configure	2011-11-20 21:24:07.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/configure	2012-07-22 16:46:02.814828000 +0000
@@ -19477,6 +19477,84 @@
 
 
 
+# For copy-assignable gthreads types
+
+
+
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -std=c++0x -I${toplevel_srcdir}/gcc"
+
+  target_thread_file=`$CXX -v 2>&1 | sed -n 's/^Thread model: //p'`
+  case $target_thread_file in
+    posix)
+      CXXFLAGS="$CXXFLAGS -DSUPPORTS_WEAK -DGTHREAD_USE_WEAK -D_PTHREADS"
+  esac
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether gthreads types are copy-assignable in C++11 mode" >&5
+$as_echo_n "checking whether gthreads types are copy-assignable in C++11 mode... " >&6; }
+
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include "gthr.h"
+int
+main ()
+{
+
+      #ifdef __GTHREAD_MUTEX_INIT
+      __gthread_mutex_t m1;
+      __gthread_mutex_t m2 = __GTHREAD_MUTEX_INIT;
+      m1 = m2;
+      #endif
+      #ifdef __GTHREAD_RECURSIVE_MUTEX_INIT
+      __gthread_recursive_mutex_t r1;
+      __gthread_recursive_mutex_t r2 = __GTHREAD_RECURSIVE_MUTEX_INIT;
+      r1 = r2;
+      #endif
+      #ifdef __GTHREAD_HAS_COND
+      #ifdef __GTHREAD_COND_INIT
+      __gthread_cond_t c1;
+      __gthread_cond_t c2 = __GTHREAD_COND_INIT;
+      c1 = c2;
+      #endif
+      #endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_gthread_cxx11_copy_assign=1
+else
+  ac_gthread_cxx11_copy_assign=0
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+  if test $ac_gthread_cxx11_copy_assign = 1 ; then res_gthr_copy_assign=yes ;
+  else res_gthr_copy_assign=no ; fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $res_gthr_copy_assign" >&5
+$as_echo "$res_gthr_copy_assign" >&6; }
+
+  if test x"$res_gthr_copy_assign" = x"no"; then
+
+$as_echo "#define _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11 1" >>confdefs.h
+
+  fi
+
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
 
   ac_fn_c_check_header_mongrel "$LINENO" "locale.h" "ac_cv_header_locale_h" "$ac_includes_default"
 if test "x$ac_cv_header_locale_h" = x""yes; then :
diff -Naur gcc-4.6.3.orig/libstdc++-v3/configure.ac gcc-4.6.3/libstdc++-v3/configure.ac
--- gcc-4.6.3.orig/libstdc++-v3/configure.ac	2011-10-05 23:09:51.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/configure.ac	2012-07-22 16:46:02.814828000 +0000
@@ -164,6 +164,9 @@
 # For gthread support
 GLIBCXX_CHECK_GTHREADS
 
+# For copy-assignable gthreads types
+GLIBCXX_GTHREADS_CXX11_COPY_ASSIGN
+
 AC_LC_MESSAGES
 
 # Check for available headers.
diff -Naur gcc-4.6.3.orig/libstdc++-v3/include/bits/stl_algo.h gcc-4.6.3/libstdc++-v3/include/bits/stl_algo.h
--- gcc-4.6.3.orig/libstdc++-v3/include/bits/stl_algo.h	2011-09-27 08:22:07.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/include/bits/stl_algo.h	2012-04-12 22:26:02.694716000 +0000
@@ -1811,7 +1811,8 @@
 	  for (; __first != __last; ++__first)
 	    if (__pred(*__first))
 	      {
-		*__result1 = _GLIBCXX_MOVE(*__first);
+		if (__result1 != __first)
+		  *__result1 = _GLIBCXX_MOVE(*__first);
 		++__result1;
 	      }
 	    else
diff -Naur gcc-4.6.3.orig/libstdc++-v3/include/debug/safe_iterator.h gcc-4.6.3/libstdc++-v3/include/debug/safe_iterator.h
--- gcc-4.6.3.orig/libstdc++-v3/include/debug/safe_iterator.h	2011-01-21 19:41:13.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/include/debug/safe_iterator.h	2012-03-08 22:31:19.955944000 +0000
@@ -1,6 +1,6 @@
 // Safe iterator implementation  -*- C++ -*-
 
-// Copyright (C) 2003, 2004, 2005, 2006, 2009, 2010, 2011
+// Copyright (C) 2003, 2004, 2005, 2006, 2009, 2010, 2011, 2012
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -142,6 +142,24 @@
 			      ._M_iterator(__x, "other"));
       }
 
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+      /**
+       * @brief Move construction.
+       * @post __x is singular and unattached
+       */
+      _Safe_iterator(_Safe_iterator&& __x) : _M_current()
+      {
+	_GLIBCXX_DEBUG_VERIFY(!__x._M_singular()
+			      || __x._M_current == _Iterator(),
+			      _M_message(__msg_init_copy_singular)
+			      ._M_iterator(*this, "this")
+			      ._M_iterator(__x, "other"));
+	std::swap(_M_current, __x._M_current);
+	this->_M_attach(__x._M_sequence);
+	__x._M_detach();
+      }
+#endif
+
       /**
        *  @brief Converting constructor from a mutable iterator to a
        *  constant iterator.
@@ -181,6 +199,27 @@
 	return *this;
       }
 
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+      /**
+       * @brief Move assignment.
+       * @post __x is singular and unattached
+       */
+      _Safe_iterator&
+      operator=(_Safe_iterator&& __x)
+      {
+	_GLIBCXX_DEBUG_VERIFY(!__x._M_singular()
+			      || __x._M_current == _Iterator(),
+			      _M_message(__msg_copy_singular)
+			      ._M_iterator(*this, "this")
+			      ._M_iterator(__x, "other"));
+	_M_current = __x._M_current;
+	_M_attach(__x._M_sequence);
+	__x._M_detach();
+	__x._M_current = _Iterator();
+	return *this;
+      }
+#endif
+
       /**
        *  @brief Iterator dereference.
        *  @pre iterator is dereferenceable
@@ -415,7 +454,9 @@
       /// Is this iterator equal to the sequence's before_begin() iterator if
       /// any?
       bool _M_is_before_begin() const
-      { return _BeforeBeginHelper<_Sequence>::_M_Is(base(), _M_get_sequence()); }
+      {
+	return _BeforeBeginHelper<_Sequence>::_M_Is(base(), _M_get_sequence());
+      }
     };
 
   template<typename _IteratorL, typename _IteratorR, typename _Sequence>
diff -Naur gcc-4.6.3.orig/libstdc++-v3/include/ext/concurrence.h gcc-4.6.3/libstdc++-v3/include/ext/concurrence.h
--- gcc-4.6.3.orig/libstdc++-v3/include/ext/concurrence.h	2011-01-30 22:39:36.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/include/ext/concurrence.h	2012-07-22 16:46:02.814828000 +0000
@@ -1,6 +1,6 @@
 // Support for concurrent programing -*- C++ -*-
 
-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -140,6 +140,18 @@
   }
 #endif
  
+  template<typename _Tp>
+    static inline void
+    __copy_gthr_type(_Tp& __to, const _Tp& __from)
+    {
+#if defined __GXX_EXPERIMENTAL_CXX0X__ \
+  && defined _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+      __builtin_memcpy(&__to, &__from, sizeof(__to));
+#else
+      __to = __from;
+#endif
+    }
+
   class __mutex 
   {
   private:
@@ -156,7 +168,7 @@
 	{
 #if defined __GTHREAD_MUTEX_INIT
 	  __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
-	  _M_mutex = __tmp;
+	  __copy_gthr_type(_M_mutex, __tmp);
 #else
 	  __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex); 
 #endif
@@ -214,7 +226,7 @@
 	{
 #if defined __GTHREAD_RECURSIVE_MUTEX_INIT
 	  __gthread_recursive_mutex_t __tmp = __GTHREAD_RECURSIVE_MUTEX_INIT;
-	  _M_mutex = __tmp;
+	  __copy_gthr_type(_M_mutex, __tmp);
 #else
 	  __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex); 
 #endif
@@ -270,7 +282,7 @@
 
     // matches a gthr-win32.h recursive mutex
     template<typename _Rm>
-      static typename __enable_if<sizeof(&_Rm::sema), void>::__type
+      static typename __enable_if<(bool)sizeof(&_Rm::sema), void>::__type
       _S_destroy(_Rm* __mx)
       {
         __gthread_mutex_t __tmp;
@@ -279,7 +291,7 @@
 
     // matches a recursive mutex with a member 'actual'
     template<typename _Rm>
-      static typename __enable_if<sizeof(&_Rm::actual), void>::__type
+      static typename __enable_if<(bool)sizeof(&_Rm::actual), void>::__type
       _S_destroy(_Rm* __mx)
       { __gthread_mutex_destroy(&__mx->actual); }
 
@@ -332,7 +344,7 @@
 	{
 #if defined __GTHREAD_COND_INIT
 	  __gthread_cond_t __tmp = __GTHREAD_COND_INIT;
-	  _M_cond = __tmp;
+	  __copy_gthr_type(_M_cond, __tmp);
 #else
 	  __GTHREAD_COND_INIT_FUNCTION(&_M_cond);
 #endif
diff -Naur gcc-4.6.3.orig/libstdc++-v3/include/ext/rope gcc-4.6.3/libstdc++-v3/include/ext/rope
--- gcc-4.6.3.orig/libstdc++-v3/include/ext/rope	2011-01-30 22:39:36.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/include/ext/rope	2012-07-22 16:46:02.814828000 +0000
@@ -1,7 +1,7 @@
 // SGI's rope class -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-// Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+// 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -445,6 +445,17 @@
     identity_element(_Rope_Concat_fn<_CharT, _Alloc>)
     { return rope<_CharT, _Alloc>(); }
 
+  static inline void
+  __copy_gthr_mutex(__gthread_mutex_t& __to, const __gthread_mutex_t& __from)
+  {
+#if defined __GXX_EXPERIMENTAL_CXX0X__ \
+  && defined _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+    __builtin_memcpy(&__to, &__from, sizeof(__to));
+#else
+    __to = __from;
+#endif
+  }
+
   // Class _Refcount_Base provides a type, _RC_t, a data member,
   // _M_ref_count, and member functions _M_incr and _M_decr, which perform
   // atomic preincrement/predecrement.  The constructor initializes
@@ -464,7 +475,7 @@
     {
 #ifdef __GTHREAD_MUTEX_INIT
       __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
-      _M_ref_count_lock = __tmp;
+      __copy_gthr_mutex(_M_ref_count_lock, __tmp);
 #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)
       __GTHREAD_MUTEX_INIT_FUNCTION (&_M_ref_count_lock);
 #else
@@ -605,7 +616,7 @@
     {
       // Do not copy a POSIX/gthr mutex once in use.  However, bits are bits.
       __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
-      _M_c_string_lock = __tmp;
+      __copy_gthr_mutex(_M_c_string_lock, __tmp);
     }
 #else
     { __GTHREAD_MUTEX_INIT_FUNCTION (&_M_c_string_lock); }
diff -Naur gcc-4.6.3.orig/libstdc++-v3/include/std/condition_variable gcc-4.6.3/libstdc++-v3/include/std/condition_variable
--- gcc-4.6.3.orig/libstdc++-v3/include/std/condition_variable	2011-12-19 00:34:29.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/include/std/condition_variable	2012-07-05 01:10:10.791368000 +0000
@@ -1,6 +1,6 @@
 // <condition_variable> -*- C++ -*-
 
-// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+// Copyright (C) 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -171,6 +171,26 @@
     condition_variable			_M_cond;
     mutex				_M_mutex;
 
+    // scoped unlock - unlocks in ctor, re-locks in dtor
+    template<typename _Lock>
+      struct _Unlock
+      {
+	explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }
+
+	~_Unlock() noexcept(false)
+	{
+	  if (uncaught_exception())
+	    __try { _M_lock.lock(); } __catch(...) { }
+	  else
+	    _M_lock.lock();
+	}
+
+	_Unlock(const _Unlock&) = delete;
+	_Unlock& operator=(const _Unlock&) = delete;
+
+	_Lock& _M_lock;
+      };
+
   public:
     typedef condition_variable::native_handle_type	native_handle_type;
 
@@ -198,21 +218,8 @@
       void
       wait(_Lock& __lock)
       {
-	// scoped unlock - unlocks in ctor, re-locks in dtor
-	struct _Unlock {
-	  explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }
-	  ~_Unlock() noexcept(false)
-	  {
-	    if (uncaught_exception())
-	      __try { _M_lock.lock(); } __catch(...) { }
-	    else
-	      _M_lock.lock();
-	  }
-	  _Lock& _M_lock;
-	};
-
 	unique_lock<mutex> __my_lock(_M_mutex);
-	_Unlock __unlock(__lock);
+	_Unlock<_Lock> __unlock(__lock);
 	// _M_mutex must be unlocked before re-locking __lock so move
 	// ownership of _M_mutex lock to an object with shorter lifetime.
 	unique_lock<mutex> __my_lock2(std::move(__my_lock));
@@ -233,11 +240,12 @@
       wait_until(_Lock& __lock,
 		 const chrono::time_point<_Clock, _Duration>& __atime)
       {
-        unique_lock<mutex> __my_lock(_M_mutex);
-        __lock.unlock();
-        cv_status __status = _M_cond.wait_until(__my_lock, __atime);
-        __lock.lock();
-        return __status;
+	unique_lock<mutex> __my_lock(_M_mutex);
+	_Unlock<_Lock> __unlock(__lock);
+	// _M_mutex must be unlocked before re-locking __lock so move
+	// ownership of _M_mutex lock to an object with shorter lifetime.
+	unique_lock<mutex> __my_lock2(std::move(__my_lock));
+	return _M_cond.wait_until(__my_lock2, __atime);
       }
 
     template<typename _Lock, typename _Clock,
diff -Naur gcc-4.6.3.orig/libstdc++-v3/include/std/mutex gcc-4.6.3/libstdc++-v3/include/std/mutex
--- gcc-4.6.3.orig/libstdc++-v3/include/std/mutex	2011-01-30 22:39:36.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/include/std/mutex	2012-07-07 18:35:52.084223000 +0000
@@ -130,7 +130,7 @@
   public:
     // matches a gthr-win32.h recursive mutex
     template<typename _Rm>
-      static typename enable_if<sizeof(&_Rm::sema), void>::type
+      static typename enable_if<(bool)sizeof(&_Rm::sema), void>::type
       _S_destroy(_Rm* __mx)
       {
         __gthread_mutex_t __tmp;
@@ -139,7 +139,7 @@
 
     // matches a recursive mutex with a member 'actual'
     template<typename _Rm>
-      static typename enable_if<sizeof(&_Rm::actual), void>::type
+      static typename enable_if<(bool)sizeof(&_Rm::actual), void>::type
       _S_destroy(_Rm* __mx)
       { __gthread_mutex_destroy(&__mx->actual); }
 
diff -Naur gcc-4.6.3.orig/libstdc++-v3/src/condition_variable.cc gcc-4.6.3/libstdc++-v3/src/condition_variable.cc
--- gcc-4.6.3.orig/libstdc++-v3/src/condition_variable.cc	2011-01-30 22:39:36.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/src/condition_variable.cc	2012-07-22 16:46:02.814828000 +0000
@@ -1,6 +1,6 @@
 // condition_variable -*- C++ -*-
 
-// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+// Copyright (C) 2008, 2009, 2010, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -34,7 +34,12 @@
   {
 #ifdef __GTHREAD_COND_INIT
     __native_type __tmp = __GTHREAD_COND_INIT;
+#if defined __GXX_EXPERIMENTAL_CXX0X__ \
+  && defined _GLIBCXX_GTHREADS_NO_COPY_ASSIGN_IN_CXX11
+    __builtin_memcpy(&_M_cond, &__tmp, sizeof(_M_cond));
+#else
     _M_cond = __tmp;
+#endif
 #else
     int __e = __gthread_cond_init(&_M_cond, 0);
 
diff -Naur gcc-4.6.3.orig/libstdc++-v3/testsuite/22_locale/ctype_base/53678.cc gcc-4.6.3/libstdc++-v3/testsuite/22_locale/ctype_base/53678.cc
--- gcc-4.6.3.orig/libstdc++-v3/testsuite/22_locale/ctype_base/53678.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/testsuite/22_locale/ctype_base/53678.cc	2012-06-20 08:30:55.151768000 +0000
@@ -0,0 +1,28 @@
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+
+// 22.2.1 The ctype category
+
+#include <locale>
+
+// libstdc++/53678
+void test01()
+{
+  bool NetBSD __attribute__((unused)) = true;
+}
diff -Naur gcc-4.6.3.orig/libstdc++-v3/testsuite/23_containers/vector/debug/52433.cc gcc-4.6.3/libstdc++-v3/testsuite/23_containers/vector/debug/52433.cc
--- gcc-4.6.3.orig/libstdc++-v3/testsuite/23_containers/vector/debug/52433.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/testsuite/23_containers/vector/debug/52433.cc	2012-03-08 22:31:19.955944000 +0000
@@ -0,0 +1,43 @@
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+// { dg-require-debug-mode "" }
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// PR libstdc++/52433
+
+#include <vector>
+
+struct X
+{
+    std::vector<int>::iterator i;
+
+    X() = default;
+    X(const X&) = default;
+    X(X&&) = default;
+    X& operator=(const X&) = default;
+    X& operator=(X&&) = default;
+};
+
+X test01()
+{
+    X x;
+    x = X();
+    return x;
+}
+
diff -Naur gcc-4.6.3.orig/libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc gcc-4.6.3/libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc
--- gcc-4.6.3.orig/libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc	2010-01-12 17:16:25.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc	2012-04-12 22:26:02.694716000 +0000
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++0x" }
 
-// Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+// Copyright (C) 2009, 2010, 2012 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -39,6 +39,11 @@
 const int B[] = {2, 4, 6, 8, 10, 12, 14, 16, 1, 3, 5, 7, 9, 11, 13, 15, 17};
 const int N = sizeof(A) / sizeof(int);
 
+// Check that starting with a true predicate works too. (PR52822)
+const int A2[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
+const int B2[] = {2, 4, 6, 8, 10, 12, 14, 16, 3, 5, 7, 9, 11, 13, 15, 17};
+const int N2 = sizeof(A2) / sizeof(int);
+
 struct Pred
 {
   bool
@@ -46,7 +51,7 @@
   { return (x.val % 2) == 0; }
 };
 
-// 25.2.12 stable_partition()
+// 25.2.12 stable_partition(), starting with a false predicate.
 void
 test01()
 {
@@ -60,9 +65,24 @@
   VERIFY( std::equal(s1, s1 + N, B) );
 }
 
+// 25.2.12 stable_partition(), starting with a true predicate.
+void
+test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  rvalstruct s1[N2];
+  std::copy(A2, A2 + N2, s1);
+  Container con(s1, s1 + N2);
+
+  std::stable_partition(con.begin(), con.end(), Pred());
+  VERIFY( std::equal(s1, s1 + N2, B2) );
+}
+
 int
 main()
 {
   test01();
+  test02();
   return 0;
 }
diff -Naur gcc-4.6.3.orig/libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc gcc-4.6.3/libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc
--- gcc-4.6.3.orig/libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc	2012-04-12 22:26:02.694716000 +0000
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 25.2.12 [lib.alg.partitions] Partitions.
+
+#include <algorithm>
+#include <vector>
+#include <testsuite_hooks.h>
+
+bool true_vector_pred(const std::vector<int>&) { return true; }
+
+void
+test01()
+{
+  std::vector<std::vector<int> > v(1);
+  v[0].push_back(7);
+  VERIFY( v[0].size() == 1 );
+  std::stable_partition(v.begin(), v.end(), &true_vector_pred);
+  VERIFY( v[0].size() == 1 );
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
diff -Naur gcc-4.6.3.orig/libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc gcc-4.6.3/libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc
--- gcc-4.6.3.orig/libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc	2012-07-05 01:10:10.791368000 +0000
@@ -0,0 +1,68 @@
+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }
+// { dg-options " -std=gnu++0x -pthread" { target *-*-freebsd* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }
+// { dg-options " -std=gnu++0x -pthreads" { target *-*-solaris* } }
+// { dg-options " -std=gnu++0x " { target *-*-cygwin *-*-darwin* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-sched-yield "" }
+// { dg-require-nanosleep "" }
+
+// Copyright (C) 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/53830
+// Test for deadlock in condition_variable_any::wait_for
+
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include <chrono>
+#include <atomic>
+
+std::mutex mutex;
+std::condition_variable_any cv;
+
+std::atomic<int> barrier(0);
+
+// waits for data from another thread
+void wait_for_data()
+{
+  std::unique_lock<std::mutex> lock(mutex);
+  barrier = 1;
+  cv.wait_for(lock, std::chrono::milliseconds(100), []{ return false; });
+  // read data
+}
+
+// passes data to waiting thread
+void provide_data()
+{
+  while (barrier == 0)
+    std::this_thread::yield();
+  std::unique_lock<std::mutex> lock(mutex);
+  // pass data
+  std::this_thread::sleep_for(std::chrono::seconds(1));
+  cv.notify_one();
+}
+
+int main()
+{
+  std::thread thread1(wait_for_data);
+  provide_data();
+  thread1.join();
+  return 0;
+}
+
diff -Naur gcc-4.6.3.orig/libstdc++-v3/testsuite/Makefile.am gcc-4.6.3/libstdc++-v3/testsuite/Makefile.am
--- gcc-4.6.3.orig/libstdc++-v3/testsuite/Makefile.am	2011-03-02 23:32:56.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/testsuite/Makefile.am	2012-04-09 01:42:09.946040000 +0000
@@ -59,6 +59,7 @@
 	@echo 'set target_triplet $(target_triplet)' >>site.tmp
 	@echo 'set libiconv "$(LIBICONV)"' >>site.tmp
 	@echo 'set baseline_dir "$(baseline_dir)"' >> site.tmp
+	@echo 'set TEST_GCC_EXEC_PREFIX "$(libdir)/gcc/"' >> site.tmp
 	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
 	@test ! -f site.exp || \
 	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
diff -Naur gcc-4.6.3.orig/libstdc++-v3/testsuite/Makefile.in gcc-4.6.3/libstdc++-v3/testsuite/Makefile.in
--- gcc-4.6.3.orig/libstdc++-v3/testsuite/Makefile.in	2011-03-08 00:04:05.000000000 +0000
+++ gcc-4.6.3/libstdc++-v3/testsuite/Makefile.in	2012-04-09 01:42:09.946040000 +0000
@@ -502,6 +502,7 @@
 	@echo 'set target_triplet $(target_triplet)' >>site.tmp
 	@echo 'set libiconv "$(LIBICONV)"' >>site.tmp
 	@echo 'set baseline_dir "$(baseline_dir)"' >> site.tmp
+	@echo 'set TEST_GCC_EXEC_PREFIX "$(libdir)/gcc/"' >> site.tmp
 	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
 	@test ! -f site.exp || \
 	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
